#abstract #interface
## Абстрактные классы и [интерфейсы](Interface) 

2023-10-24 17:27

От абстрактных классов и интерфейсов нельзя создавать объекты. Они служат своего рода шаблонами для обычных классов.

Абстрактный класс – это некое обобщение. Например, не существует конкретного объекта, напрямую созданного от класса Млекопитающие. Класс Млекопитающие – обобщение, абстракция. От этого класса создаются дочерние классы – отряды, и только от них уже создаются объекты. Абстрактный класс отвечает на вопрос "что чем является". Например, парнокопытные являются млекопитающими.

[Интерфейс](Interface) – это в большинстве случаев определенная функциональность. Например, способность летать, распаковывать архив, парсить страницу. Интерфейс может наследоваться любым классом. Интерфейс отвечает на вопрос "у кого что есть". Например, у самолетов и птиц есть способность к полету. Несвязанные между собой ближайшим общим предком классы могут наследовать один и тот же интерфейс.

Один класс может использовать несколько интерфейсов. Этим объясняется их популярность в Java, так как здесь отсутствием множественное наследование классов.

### Абстрактные классы 

В Java, чтобы объявить класс абстрактным, надо в заголовке прописать слово abstract. Также обычно должен быть хотя бы один абстрактный метод. Рассмотрим пример:
```java
public class AbstrTest {
    public static void main(String[] args) {
        UsualClass a = new UsualClass();
        a.strPrint();
        a.intPrint();
    }
}
 
abstract class AbstrClass {
 
    abstract void strPrint();
 
    void intPrint() {
        System.out.println(1);
    }
}
 
class UsualClass extends AbstrClass {
    void strPrint() {
        System.out.println("hi");
    }
}
```
В данном случае
- Нельзя создавать объекты от класса AbstrClass, так как в его заголовке есть слово abstract. (Однако переменную такого типа можно было бы создать.)
- Нельзя опустить реализацию метода strPrint() в классе UsualClass, поскольку он наследник абстрактного класса, в котором указанный метод объявлен абстрактным.
- Абстрактные методы не имеют тел.
- Если бы класс AbstrClass не содержал абстрактный strPrint(), или метод был бы не абстрактным, то в UsualClass можно было бы не переопределять данный метод. Таким образом, объявляя абстрактные методы, мы заставляем дочерние классы придерживаться определенного стандарта.
- Абстрактный класс может не иметь абстрактных методов. Отличие такого класса от обычного родительского только в том, что от него нельзя создавать объекты.

### Интерфейсы

При определении интерфейсов вместо class пишется ключевое слово [interface](Interface). Если есть родительские интерфейсы, они также как в случае классов перечисляются после слова extends. У интерфейсов не может быть родительских классов.

Поскольку все методы интерфейсов по умолчанию абстрактные и публичные, перед их именами не требуется писать соответствующих модификаторов.

Если класс использует интерфейс, имя интерфейса указывается после слова implements (реализует). В случае наследования нескольких интерфейсов они перечисляются через запятую. Наследовать интерфейсы могут как обычные, так и абстрактные классы.

Если класс является наследником как другого класса, так интерфейса, в его заголовке сначала пишется extends имя_класса, затем implements имя_интерфейса.
```java
interface InterFace {
    String getStr();
}
 
class UsualClass extends AbstrClass 
                implements InterFace {
    void strPrint() {
        System.out.println("hi");
    }
    public String getStr() {
        return "HI";
    }
}
```
Если не указать слово public в реализации метода getStr(), будет ошибка.

Зачем нужны абстрактные методы, будь они в абстрактных классах или интерфейсах, если вся их реализация ложится на плечи дочерних классов? Если вы создаете группу порожденных от сестринских классов объектов, то можете присваивать их переменным типа абстрактного класса или интерфейса и обрабатывать всю группу, например, в одном цикле. У всей группы будут одни и те же методы, хотя реализация будет зависеть от типа объекта.
```java
import java.util.ArrayList;
 
public class ListObjects {
    public static void main(String[] args) {
        ArrayList<Animal> house = new ArrayList<>();
        house.add(new Cat());
        house.add(new Dog());
        house.add(new Dog());
 
        for (Animal animal : house) {
            animal.voice();
        }
    }
}
 
abstract class Animal {
    abstract void voice();
}
 
class Cat extends Animal {
    void voice() {
        System.out.println("Meow");
    }
}
 
class Dog extends Animal {
    void voice() {
        System.out.println("Woof");
    }
}
```
Приведенная программа один раз мяукнет и два раза гавкнет, так как для каждого животного будет вызвана его реализация метода. Это также пример полиморфизма.

В случае наследования интерфейса было бы так:
```java
interface Animal {
    void voice();
}
 
class Cat implements Animal {
    public void voice() {
        System.out.println("Meow");
    }
}
 
class Dog implements Animal {
    public void voice() {
        System.out.println("Woof");
    }
}
```
В Java над переопределяемыми методами принято писать аннотацию @Override. Так при взгляде на класс сразу понятно, что метод не определяется, а переопределяется.

В последних версиях языка Java в интерфейсах можно писать реализацию методов. Перед такими методами добавляется ключевое слово default:
```java
interface Animal {
 
    void voice();
 
    default void drink() {
        System.out.println("I drink!");
    }
}
```
