#Java #DesignPatterns #Adapter

## [Паттерн проектирования Адаптер](https://refactoringguru.cn/ru/design-patterns/adapter/java/example)

2024-06-27 16:04

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.

### Применимость

 Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

 Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

 Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.

 Вы могли бы создать ещё один уровень подклассов и добавить в них недостающую функциональность. Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.

Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать паттерн Декоратор.

### Шаги реализации

1. Убедитесь, что у вас есть два класса с несовместимыми интерфейсами:
    - полезный _сервис_ — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
    - один или несколько _клиентов_ — существующих классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.
2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
3. Создайте класс адаптера, реализовав этот интерфейс.
4. Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса. Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.
6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

### Преимущества и недостатки

-  Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
-  Усложняет код программы из-за введения дополнительных классов.

#### [Пример 1](https://javarush.com/groups/posts/2139-pattern-proektirovanija-adapter)

Представь, что у нас есть какая-то карта памяти. В чем состоит проблема? В том, что она не умеет взаимодействовать с компьютером. У них нет общего интерфейса. У компьютера есть разъем USB, но карту памяти в него не вставить. Карту невозможно вставить в компьютер, из-за чего мы не сможем сохранить наши фотографии, видео и другие данные. Кардридер является адаптером, решающим данную проблему. Ведь у него есть USB-кабель! В отличие от самой карты, кардридер можно вставить в компьютер. У них с компьютером есть общий интерфейс — USB. Давай посмотрим, как это будет выглядеть на примере:
```java
public interface USB {
   void connectWithUsbCable();
}```
Это наш интерфейс USB с единственным методом — вставить USB-кабель.

```java
public class MemoryCard {

   public void insert() {
       System.out.println("Карта памяти успешно вставлена!");
   }

   public void copyData() {
       System.out.println("Данные скопированы на компьютер!");
   }
}
```
Это наш класс, реализующий карту памяти. В нем уже есть 2 нужных нам метода, но вот беда: интерфейс USB он не реализует. Карту нельзя вставить в USB-разъем.

```java
public class CardReader implements USB {

   private MemoryCard memoryCard;

   public CardReader(MemoryCard memoryCard) {
       this.memoryCard = memoryCard;
   }

   @Override
   public void connectWithUsbCable() {
       this.memoryCard.insert();
       this.memoryCard.copyData();
   }
}
```
А вот и наш адаптер!

Что же делает класс CardReader и почему, собственно, он является адаптером?

Все просто. Адаптируемый класс (карта памяти) становится одним из полей адаптера. Это логично, ведь в реальной жизни мы тоже вставляем карту внутрь кардридера, и она тоже становится его частью.

В отличие от карты памяти, у адаптера есть общий интерфейс с компьютером. У него есть USB-кабель, то есть он может соединяться с другими устройствами по USB.

Поэтому в программе наш класс CardReader реализует интерфейс USB. Но что же происходит внутри этого метода?

А там происходит ровно то, что нам нужно! Адаптер делегирует выполнение работы нашей карте памяти. Ведь сам-то адаптер ничего не делает, какого-то самостоятельного функционала у кардридера нет. Его задача — только связать компьютер и карту памяти, чтобы карта могла сделать свою работу и скопировать файлы!

Наш адаптер позволяет ей сделать это, предоставив свой интерфейс (метод connectWithUsbCable()) для «нужд» карты памяти.

Давай создадим какую-то программу-клиент, которая будет имитировать человека, желающего скопировать данные с карты памяти:
```java
public class Main {

   public static void main(String[] args) {

       USB cardReader = new CardReader(new MemoryCard());
       cardReader.connectWithUsbCable();

   }
}
```
Что же у нас в результате получилось?

Вывод в консоль:
<p style="background-color: navy; color: yellow">
Карта памяти успешно вставлена!<br>
Данные скопированы на компьютер!</p>

#### Пример 2

[Reader](Reader) — это абстрактный класс, поэтому явно создавать его объекты у нас не получится.
Классы [BufferedReader](BufferedReader) и [InputStreamReader](InputStreamReader) являются его наследниками.
```java
public class BufferedReader extends Reader {
…
}

public class InputStreamReader extends Reader {
…
}
```
Класс [InputStreamReader](InputStreamReader) — это классический адаптер. Мы можем передать в его конструктор объект [InputStream](InputStream). Чаще всего мы для этого используем переменную System.in:
```java
public static void main(String[] args) {

   InputStreamReader inputStreamReader = new InputStreamReader(System.in);
}
```
Что же делает [InputStreamReader](InputStreamReader)? Как и всякий адаптер, он преобразует один интерфейс к другому. В данном случае — интерфейс InputStream’a к интерфейсу Reader’a.

Изначально у нас был класс [InputStream](InputStream). Он неплохо работает, но с его помощью можно читать только отдельные байты.

Кроме того, у нас есть абстрактный класс [Reader](Reader). У него есть отличный и очень нужный нам функционал — он умеет читать символы! Нам такая возможность, конечно, очень нужна.

Но здесь мы сталкиваемся с классической проблемой, которую обычно решают адаптеры — несовместимость интерфейсов. В чем же она проявляется?

Метод read() у этого класса есть (даже в нескольких вариантах), но читать он может только байты: или отдельные байты, или несколько байт с использованием буфера. Нам такой вариант не подходит — мы хотим читать символы.

Нужный нам функционал уже реализован в абстрактном классе [Reader](Reader).

Однако интерфейсы InputStream'a и Reader'a несовместимы! Как видишь, во всех реализациях метода read() у них отличаются и передаваемые параметры, и возвращаемые значения.

И именно здесь нам понадобится [InputStreamReader](InputStreamReader)! Он выступит Адаптером между нашими классами. Теперь передаем объект [InputStream](InputStream) в конструктор [InputStreamReader](InputStreamReader)!

В качестве [InputStream](InputStream) мы используем уже ставшую привычной переменную System.in:
```java
public static void main(String[] args) {
   InputStreamReader inputStreamReader = new InputStreamReader(System.in);
}
```
И хотя изначально наш объект System.in (поток, привязанный к клавиатуре) не позволял этого делать, создав паттерн Адаптер создатели языка решили эту проблему.

У абстрактного класса [Reader](Reader), как и у большинства I/O-классов, есть брат-близнец — Writer. Он имеет тот же большой плюс, что и [Reader](Reader) — предоставляет удобный интерфейс для работы с символами.

С выходными потоками проблема и ее решение выглядят так же, как и в случае со входными. 

Есть класс [OutputStream](OutputStream), который умеет записывать только байты; есть абстрактный класс [Writer](Writer), который умеет работать с символами, и есть два несовместимых интерфейса.

Эту проблему вновь успешно решает паттерн Адаптер. При помощи класса [OutputStreamWriter](OutputStreamWriter) мы легко «адаптируем» два интерфейса классов [Writer](Writer) и [OutputStream](OutputStream) друг другу. И, получив байтовый поток [OutputStream](OutputStream) в конструктор, с помощью [OutputStreamWriter](OutputStreamWriter) мы, тем не менее, можем записывать символы, а не байты!
```java
import java.io.*;

public class Main {

   public static void main(String[] args) throws IOException {

       OutputStreamWriter streamWriter = new OutputStreamWriter(new FileOutputStream("C:\\book\\test.txt"));
       streamWriter.write(32144);
       streamWriter.close();
   }
}
```
Мы записали в наш файл символ с кодом 32144 — 綐, таким образом избавившись от необходимости работать с байтами.
