### Типы коллекций. Интерфейс Collection ###

#Java #ArrayList #LinkedList

Создано: 2023-09-11 17:27

Коллекции — это наборы однородных элементов. Инструменты для работы с такими структурами в Java содержатся в **Java Collections Framework**. Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками: сортировки, поиска, преобразования.
![[Collections.jpg]]
Классы коллекций располагаются в пакете **`java.util`**, поэтому перед применением коллекций следует подключить данный пакет.
Хотя в Java существует множество коллекций, но все они образуют стройную и логичную систему. Во-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет базовый функционал. Среди этих интерфейсов можно выделить следующие:
- [[Collections#Интерфейс Java Collection|Collection]]: базовый интерфейс для всех коллекций и других интерфейсов коллекций
- [Queue](Queue): наследует интерфейс Collection и представляет функционал для структур данных в виде очереди. В таком списке элементы можно добавлять только в хвост, а удалять — только из начала. Так реализуется концепция **FIFO** (**first in, first out)** — «первым пришёл — первым ушёл».
- [Deque](Deque): наследует интерфейс [Queue](Queue) и представляет функционал для двунаправленных очередей.  
><span style="color: lightgreen"><i>Будет здорово, если на собеседовании вы назовёте <b>Deque</b> правильно: «дэк», а не «дэкью», как часто говорят.</i></span>
- [List](List): наследует интерфейс Collection и представляет функциональность простых списков  
- [Set](Set): также расширяет интерфейс Collection и используется для хранения множеств уникальных объектов
- SortedSet: расширяет интерфейс Set для создания сортированных коллекций
- NavigableSet: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию
- [Map](Map): предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection.  
><span style="color: lightgreen"><i>Не путайте интерфейс <b>Collection</b> и фреймворк <b>Collections</b>. <b>Map</b> не наследуется от интерфейса Collection, но входит в состав фреймворка Collections.</i></span>

Эти интерфейсы частично реализуются абстрактными классами:
- AbstractCollection: базовый абстрактный класс для других коллекций, который применяет интерфейс Collection
- AbstractList: расширяет класс AbstractCollection и применяет интерфейс List, предназначен для создания коллекций в виде списков
- AbstractSet: расширяет класс AbstractCollection и применяет интерфейс Set для создания коллекций в виде множеств
- AbstractQueue: расширяет класс AbstractCollection и применяет интерфейс [Queue](Queue), предназначен для создания коллекций в виде очередей и стеков
- AbstractSequentialList: также расширяет класс AbstractList и реализует интерфейс [List](List). Используется для создания связанных списков
- AbstractMap: применяет интерфейс [Map](Map), предназначен для создания наборов по типу словаря с объектами в виде пары "ключ-значение"

С помощью применения вышеописанных интерфейсов и абстрактных классов в Java реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие:
- [ArrayList](Class-ArrayList): простой список объектов
- [LinkedList](Class-LinkedList): представляет связанный список
- [ArrayDeque](ArrayDeque): класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце
- HashSet: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код. 
- TreeSet: набор отсортированных объектов в виде дерева
- LinkedHashSet: связанное хеш-множество
- [PriorityQueue](PriorityQueue): очередь приоритетов
- HashMap: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение
- TreeMap: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение

### Интерфейс Java Collection 

Интерфейс Java Collection (java.util.Collection) - один из корневых интерфейсов Java Collection API. Вы создаете не экземпляр Collection напрямую, а экземпляр одного из подтипов Collection. Вот пример создания списка, который является подтипом коллекции: 
```java
Collection collection = new ArrayList();
```
Приведенный выше пример работает для каждого подтипа коллекции.
Вот метод, который работает с коллекцией:
```java
public class MyCollectionUtil{
  public static void doSomething(Collection collection) {
    
    Iterator iterator = collection.iterator();
    while(iterator.hasNext()){
      Object object = iterator.next();

      //do something to object here...
    }
  }
}
```
И вот несколько способов вызвать этот метод с различными подтипами коллекции:
```java
Set  set  = new HashSet();
List list = new ArrayList();

MyCollectionUtil.doSomething(set);
MyCollectionUtil.doSomething(list);
```
Интерфейс Collection является обобщенным и расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в цикле по типу **`for-each`**. 
Вы можете выполнить итерацию по всем элементам коллекции. Это делается путем получения итератора Java из коллекции и выполнения итерации по нему. Вот как это выглядит: 
```java
Collection collection = new HashSet();
//... add elements to the collection

Iterator iterator = collection.iterator();
while(iterator.hasNext()){
    Object object = iterator.next();
    System.out.println(object);
}
```
Вы также можете выполнить итерацию коллекции Java, используя цикл Java for-each :
```java
Collection collection = new HashSet();
collection.add("A");
collection.add("B");
collection.add("C");

for(Object object : collection) {
    System.out.println(object);
}
```
Среди методов интерфейса Collection можно выделить следующие:
- **`boolean add (E item)`**: добавляет в коллекцию объект item. При удачном добавлении возвращает true, при неудачном - false. Независимо от того, какой подтип коллекции вы используете, существует несколько стандартных методов добавления элементов в коллекцию. Добавление элемента в коллекцию осуществляется с помощью метода add(). Вот пример добавления элемента в коллекцию Java:
```java
String     anElement  = "an element";
Collection collection = new HashSet();

boolean didCollectionChange = collection.add(anElement);
```
- **`boolean addAll (Collection<? extends E> col)`**: добавляет в коллекцию все элементы из коллекции col. При удачном добавлении возвращает true, при неудачном - false. Вы также можете добавить коллекцию объектов в коллекцию Java с помощью функции addAll(). Вот пример добавления коллекции объектов в коллекцию Java:
```java
Set  aSet  = ... // get Set  with elements from somewhere
Collection collection = new HashSet();
collection.addAll(aSet);    //returns boolean too, but ignored here
```
Java Collection addAll() добавляет все элементы, найденные в коллекции, переданной в качестве параметра методу. Сам объект коллекции не добавляется. Только его элементы. Если бы вы вместо этого вызвали add() с Collection в качестве параметра, был бы добавлен сам объект Collection, а не его элементы. Точное поведение метода addAll() зависит от подтипа коллекции. Некоторые подтипы коллекций позволяют добавлять один и тот же элемент более одного раза, а другие - нет.
- **`void clear ()`**: удаляет все элементы из коллекции
- **`boolean contains(Object item)`** и **`boolean containsAll(Object items)`**: возвращает true, если объект item содержится в коллекции, иначе возвращает false.
```java
Collection collection   = new HashSet();
boolean containsElement = collection.contains("an element");
Collection elements     = new HashSet();
boolean containsAll     = collection.containsAll(elements);
```
- **`boolean isEmpty ()`**: возвращает true, если коллекция пуста, иначе возвращает false
- **`Iterator<E> iterator ()`**: возвращает объект Iterator для обхода элементов коллекции
- **`boolean remove (Object item)`**. Метод remove() удаляет элемент из коллекции и возвращает значение true, если удаленный элемент присутствовал в коллекции и был удален. Если элемент отсутствовал, метод remove() возвращает значение false. Вот пример удаления элемента из коллекции Java:
```java
boolean wasElementRemoved = collection.remove("an element");
```
- **`boolean removeAll (Collection<?> col)`**: удаляет все объекты коллекции col из текущей коллекции. Если текущая коллекция изменилась, возвращает true, иначе возвращается false. Если параметр Collection содержит какие-либо элементы, не найденные в целевой коллекции, они просто игнорируются. Вот пример удаления коллекции элементов из коллекции Java:
```java
Collection objects = //... get a collection of objects from somewhere.
collection.removeAll(objects);
```
- **`boolean retainAll (Collection<?> col)`**: удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции col. Если текущая коллекция после удаления изменилась, возвращает true, иначе возвращается false.
```java
Collection colA = new ArrayList();
Collection colB = new ArrayList();

colA.add("A");
colA.add("B");
colA.add("C");

colB.add("1");
colB.add("2");
colB.add("3");

Collection target = new HashSet();

target.addAll(colA);     //target now contains [A,B,C]
target.addAll(colB);     //target now contains [A,B,C,1,2,3]

target.retainAll(colB);  //target now contains [1,2,3]
```
- **`int size ()`**: возвращает число элементов в коллекции:
```java
int numberOfElements = collection.size();
```
- **`Object[] toArray ()`**: возвращает массив, содержащий все элементы коллекции

Коллекции в свою очередь делится на другие большие подгруппы.
### [List](List) ###

К нему относится список (интерфейс **List**), где в определенной последовательности хранится группа элементов. К существующим методам коллекции у списка добавлены новые методы **set()**, **get()**, **indexOf**. Главная отличительная особенность - вы всегда можете пронумеровать элементы списка. Представьте себе подписанные коробки, в которых сидят коты, вы всегда можете обратиться к нужному коту по номеру коробки. При этом допускаются коты-однофамильцы, то есть одинаковые элементы.

Классы, работающие с интерфейсом **List**:

- [**ArrayList**](Class-ArrayList) - индексированная динамически расширяющая и сокращающая последовательность
- [**LinkedList**](Class-LinkedList) - упорядоченная последовательность, допускающая эффективную вставку и удаление на любой позиции

Контейнеры **ArrayList** и **LinkedList** принадлежат к семейству [List](List) и элементы в них хранятся в порядке вставки. Они различаются не только скоростью выполнения тех или иных операций, но и тем, что **LinkedList** содержит больше операций, чем **ArrayList**.

### [Set](Set) ###

Множество **Set**, в которое можно добавлять только по одному элементу определённого типа. Но при этом, вы не можете их получить по индексу. Воспринимайте множество как большую общую комнату, в которой свободно гуляют коты. Вы можете их пересчитать, вы можете проверить, что в комнате есть и Мурзик, и Васька, но в каком именно месте они сейчас спят? Может стоит прикупить коробки? В отличие от списка, коты с одинаковыми именами в такой комнате жить не могут. Это главное свойство множества - все элементы уникальны.
<span style="color: lightgreen"><i><b>Хеш-таблица</b> — структура данных, в которой все элементы помещаются в бакеты (buckets), соответствующие результату вычисления хеш-функции.</i></span>
<span style="color: lightgreen"><i><b>Например</b>, администратор в гостинице может класть ключ в коробку с номером от 1 до 9, вычисляя его по такому алгоритму: складывать все цифры номера, пока не получится одноразрядное число.

Здесь алгоритм вычисления — хеш-функция, а результат вычисления — хеш-код.

Тогда ключ от номера 356 попадёт в коробку 5 (3 + 5 + 6 = 14; 1 + 4 = 5), а ключ от номера 123 — в коробку с номером 6.</i></span>
- **HashSet** - неупорядоченная коллекция, исключающая дубликаты
- **TreeSet** - отсортированное множество
- **EnumSet** - множество значений перечислимого типа
- **LinkedHashSet** - множество, запоминающее порядок ввода элементов

### [Queue](Queue) ###

Очередь **[Queue](Queue)**.

- **[ArrayDeque](ArrayDeque)** - упорядоченная последовательность в виде циклического массива
- **[PriorityQueue](PriorityQueue)** - коллекция, позволяющая эффективно удалять наименьший элемент
