### Типы коллекций. Интерфейс Collection ###

#Java #ArrayList #LinkedList

Создано: 2023-09-11 17:27

Коллекции — это наборы однородных элементов. Инструменты для работы с такими структурами в Java содержатся в **Java Collections Framework**. Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками: сортировки, поиска, преобразования.
![[Collections.jpg]]
Классы коллекций располагаются в пакете **`java.util`**, поэтому перед применением коллекций следует подключить данный пакет.
Хотя в Java существует множество коллекций, но все они образуют стройную и логичную систему. Во-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет базовый функционал. Среди этих интерфейсов можно выделить следующие:
- Collection: базовый интерфейс для всех коллекций и других интерфейсов коллекций
- Queue: наследует интерфейс Collection и представляет функционал для структур данных в виде очереди. В таком списке элементы можно добавлять только в хвост, а удалять — только из начала. Так реализуется концепция **FIFO** (**first in, first out)** — «первым пришёл — первым ушёл».
- Deque: наследует интерфейс Queue и представляет функционал для двунаправленных очередей. <span style="color: lightgreen"><i>Будет здорово, если на собеседовании вы назовёте <b>Deque</b> правильно: «дэк», а не «дэкью», как часто говорят.</i></span>
- List: наследует интерфейс Collection и представляет функциональность простых списков  
- Set: также расширяет интерфейс Collection и используется для хранения множеств уникальных объектов
- SortedSet: расширяет интерфейс Set для создания сортированных коллекций
- NavigableSet: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию
- Map: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection.  <span style="color: lightgreen"><i>Не путайте интерфейс <b>Collection</b> и фреймворк <b>Collections</b>. <b>Map</b> не наследуется от интерфейса Collection, но входит в состав фреймворка Collections.</i></span>

Эти интерфейсы частично реализуются абстрактными классами:
- AbstractCollection: базовый абстрактный класс для других коллекций, который применяет интерфейс Collection
- AbstractList: расширяет класс AbstractCollection и применяет интерфейс List, предназначен для создания коллекций в виде списков
- AbstractSet: расширяет класс AbstractCollection и применяет интерфейс Set для создания коллекций в виде множеств
- AbstractQueue: расширяет класс AbstractCollection и применяет интерфейс Queue, предназначен для создания коллекций в виде очередей и стеков
- AbstractSequentialList: также расширяет класс AbstractList и реализует интерфейс List. Используется для создания связанных списков
- AbstractMap: применяет интерфейс Map, предназначен для создания наборов по типу словаря с объектами в виде пары "ключ-значение"

С помощью применения вышеописанных интерфейсов и абстрактных классов в Java реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие:
- ArrayList: простой список объектов
- LinkedList: представляет связанный список
- ArrayDeque: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце
- HashSet: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код. 
- TreeSet: набор отсортированных объектов в виде дерева
- LinkedHashSet: связанное хеш-множество
- PriorityQueue: очередь приоритетов
- HashMap: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение
- TreeMap: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение

Интерфейс **Collection** является самым главным для классов коллекций в библиотеке Java. Два основных метода интерфейса.  Интерфейс Collection является обобщенным и расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в цикле по типу **`for-each`**.

Среди методов интерфейса Collection можно выделить следующие:
- **`boolean add (E item)`**: добавляет в коллекцию объект item. При удачном добавлении возвращает true, при неудачном - false
- **`boolean addAll (Collection<? extends E> col)`**: добавляет в коллекцию все элементы из коллекции col. При удачном добавлении возвращает true, при неудачном - false
- **`void clear ()`**: удаляет все элементы из коллекции
- **`boolean contains (Object item)`**: возвращает true, если объект item содержится в коллекции, иначе возвращает false
- **`boolean isEmpty ()`**: возвращает true, если коллекция пуста, иначе возвращает false
- **`Iterator<E> iterator ()`**: возвращает объект Iterator для обхода элементов коллекции
- **`boolean remove (Object item)`**: возвращает true, если объект item удачно удален из коллекции, иначе возвращается false
- **`boolean removeAll (Collection<?> col)`**: удаляет все объекты коллекции col из текущей коллекции. Если текущая коллекция изменилась, возвращает true, иначе возвращается false
- **`boolean retainAll (Collection<?> col)`**: удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции col. Если текущая коллекция после удаления изменилась, возвращает true, иначе возвращается false
- **`int size ()`**: возвращает число элементов в коллекции
- **`Object[] toArray ()`**: возвращает массив, содержащий все элементы коллекции

Коллекции в свою очередь делится на другие большие подгруппы.
### List ###

К нему относится список (интерфейс **List**), где в определенной последовательности хранится группа элементов. К существующим методам коллекции у списка добавлены новые методы **set()**, **get()**, **indexOf**. Главная отличительная особенность - вы всегда можете пронумеровать элементы списка. Представьте себе подписанные коробки, в которых сидят коты, вы всегда можете обратиться к нужному коту по номеру коробки. При этом допускаются коты-однофамильцы, то есть одинаковые элементы.

Классы, работающие с интерфейсом **List**:

- [**ArrayList**](Class ArrayList) - индексированная динамически расширяющая и сокращающая последовательность
- [**LinkedList**](Class LinkedList) - упорядоченная последовательность, допускающая эффективную вставку и удаление на любой позиции

Контейнеры **ArrayList** и  **LinkedList** принадлежат к семейству [List](https://developer.alexanderklimov.ru/android/java/arraylist.php#list) и элементы в них хранятся в порядке вставки. Они различаются не только скоростью выполнения тех или иных операций, но и тем, что **LinkedList** содержит больше операций, чем **ArrayList**.

### Set ###

Множество **Set**, в которое можно добавлять только по одному элементу определённого типа. Но при этом, вы не можете их получить по индексу. Воспринимайте множество как большую общую комнату, в которой свободно гуляют коты. Вы можете их пересчитать, вы можете проверить, что в комнате есть и Мурзик, и Васька, но в каком именно месте они сейчас спят? Может стоит прикупить коробки? В отличие от списка, коты с одинаковыми именами в такой комнате жить не могут. Это главное свойство множества - все элементы уникальны.
<span style="color: lightgreen"><i><b>Хеш-таблица</b> — структура данных, в которой все элементы помещаются в бакеты (buckets), соответствующие результату вычисления хеш-функции.</i></span>
<span style="color: lightgreen"><i><b>Например</b>, администратор в гостинице может класть ключ в коробку с номером от 1 до 9, вычисляя его по такому алгоритму: складывать все цифры номера, пока не получится одноразрядное число.

Здесь алгоритм вычисления — хеш-функция, а результат вычисления — хеш-код.

Тогда ключ от номера 356 попадёт в коробку 5 (3 + 5 + 6 = 14; 1 + 4 = 5), а ключ от номера 123 — в коробку с номером 6.</i></span>
- **HashSet** - неупорядоченная коллекция, исключающая дубликаты
- **TreeSet** - отсортированное множество
- **EnumSet** - множество значений перечислимого типа
- **LinkedHashSet** - множество, запоминающее порядок ввода элементов

### Queue ###

Очередь **Queue**.

- **ArrayDeque** - упорядоченная последовательность в виде циклического массива
- **PriorityQueue** - коллекция, позволяющая эффективно удалять наименьший элемент
