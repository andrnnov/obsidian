#Java #CyclicBarrier
### [Объект синхронизации CyclicBarrier](https://java-online.ru/concurrent-synchronizers.xhtml) ###

2023-12-27 15:12

Объект синхронизации _CyclicBarrier_ представляет собой барьерную синхронизацию, используемую, как правило, в распределённых вычислениях. Особенно эффективно использование барьеров при циклических расчетах. При барьерной синхронизации алгоритм расчета делят на несколько потоков. С помощью барьера организуют точку сбора частичных результатов вычислений, в которой подводится итог этапа вычислений.

В исходном коде барьер для группы потоков означает, что каждый поток должен остановиться в определенном месте и ожидать прихода остальных потоков группы. Как только все потоки достигнут барьера, их выполнение продолжится.

Класс CyclicBarrier имеет 2 конструктора:
```java
CyclicBarrier(int count);
CyclicBarrier(int count, Runnable class);
```
В первом конструкторе задается количество потоков, которые должны достигнуть барьера, чтобы после этого одновременно продолжить выполнение кода. Во втором конструкторе дополнительно задается реализующий интерфейс Runnable класс, который должен быть запущен после прихода к барьеру всех потоков. Поток запускать самостоятельно НЕ НУЖНО. _CyclicBarrier_ это делает автоматически.

Для указания потоку о достижении барьера нужно вызвать один из перегруженных методов await :
```java
void await() throws InterruptedException 
boolean await(long wait, TimeUnit unit) throws InterruptedException;
```
Назначение параметров wait и unit у второго метода описано выше (см. [[CountDownLatch#Метод самоблокировки await|CountDownLatch]]).

Циклический барьер _CyclicBarrier_ похож на **CountDownLatch**. Главное различие между ними связано с тем, что «защелку» нельзя использовать повторно после того, как её счётчик обнулится, а барьер можно использовать (в цикле). С точки зрения API циклический барьер CyclicBarrier имеет только метод самоблокировки await и не имеет метода декрементации счетчика, а также позволяет подключить и автоматически запускать дополнительный потоковый класс при достижении барьера всех исполняемых потоков.

**Пример использования CyclicBarrier**

В примере организуется переправа. Паром может вместить только 3 автомобиля. Количество автомобилей 9. Роль парома выполняет объект синхронизации FerryBarrier, которому в качестве второго параметра передается реализующий интерфейс Runnable класс FerryBoat. Как только 3 потока достигнут барьера автоматически будет запущен FerryBoat, после завершения работы которого потоки продолжают свою работу.
```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
    private static CyclicBarrier FerryBarrier;
    private static final int FerryBoat_size = 3;

    // Переправляющий автомобили паром
    public static class FerryBoatimplements Runnable {
        @Override
        public void run() {
            try {
                // Задержка на переправе System.out.println(
                          "\nЗагрузка автомобилей");
                Thread.sleep(500);
                System.out.println(
                          "Паром переправил автомобили\n");
            } catch (InterruptedException e) {}
        }
    }

    // Класс автомобиля
    public static class Car implements Runnable {
        private int carNumber;

        public Car(int carNumber) {
            this.carNumber = carNumber;
        }

        @Override
        public void run() {
            try {
                System.out.printf(
                   "К переправе подъехал автомобиль %d\n",
                                               carNumber);
                // Вызов метода await при подходе к // барьеру; поток блокируется в ожидании // прихода остальных потоков
                FerryBarrier.await();
                System.out.printf(
                      "Автомобиль %d продолжил движение\n",
                                                carNumber);
            } catch (Exception e) {}
        }
    }

    public static void main(String[] args) throws InterruptedException {
        FerryBarrier = new CyclicBarrier(FerryBoat_size, new FerryBoat());
        for (int i = 1; i < 10; i++) {
            new Thread(new Car(i)).start();
            Thread.sleep(400);
        }
    }
}
```
Обратите внимание, что потоки подходят к барьеру с интервалом в 400 ms. Время задержки у барьера/переправы (после того, как собралось необходимое количество потоков), составляет 500 ms, если не считать время вывода сообщений в консоль. За это время к барьеру успевает подойти еще один поток. Что мы и видим при выводе сообщений в консоль.
**Результат выполнения примера**

Варьируя временем на переправе и временем прихода автомобилей на переправу, можно либо заставить паром простаивать, либо будут простаивать автомобили на переправе.
<p style="background-color: navy; color: yellow">
К переправе подъехал автомобиль 1<br>
К переправе подъехал автомобиль 2<br>
К переправе подъехал автомобиль 3<br>
<br>
Загрузка автомобилей<br>
К переправе подъехал автомобиль 4<br>
Паром переправил автомобили<br>
<br>
Автомобиль 3 продолжил движение<br>
Автомобиль 1 продолжил движение<br>
Автомобиль 2 продолжил движение<br>
К переправе подъехал автомобиль 5<br>
К переправе подъехал автомобиль 6<br>
<br>
Загрузка автомобилей<br>
К переправе подъехал автомобиль 7<br>
Паром переправил автомобили<br>
<br>
Автомобиль 6 продолжил движение<br>
Автомобиль 5 продолжил движение<br>
Автомобиль 4 продолжил движение<br>
К переправе подъехал автомобиль 8<br>
К переправе подъехал автомобиль 9<br>
<br>
Загрузка автомобилей<br>
Паром переправил автомобили<br>
<br>
Автомобиль 7 продолжил движение<br>
Автомобиль 9 продолжил движение<br>
Автомобиль 8 продолжил движение</p>