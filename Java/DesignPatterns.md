#Java #DesignPatterns

## Шаблоны проектирования в Java

2024-06-27 15:25

Java – объектно-ориентированный язык программирования. Он относится к общему назначению. Используется программистами на практике достаточно часто. Обладает широким функционалом и неплохой работоспособностью.

Можно отнести Java к языкам программирования кроссплатформенного характера. На нем пишут мобильный и компьютерный софт. Пример успешного проекта – Minecraft.

### Определение

Шаблоны проектирования – это паттерны. Представляют собой готовые для применения на практике решения часто возникающих в коддинге задач. Не выступают в качестве классом или библиотек, подключаемых к проекту. Паттерны проектирования – нечто большее.

Реализация оных осуществляется в каждом отдельно взятом случае. Требуют подобные объекты пристального внимания со стороны разработчика. Если паттерн неправильно или неграмотно применить, это приведет к серьезным затруднениям.

Паттерн – повторяемая архитектурная конструкция, представляющая готовое решение проблемы проектирования в рамках некоторого регулярно возникающего контекста. Готовый шаблон, которые не является законченным образцом. Он может быть прямо преобразован в кодификацию.

Объектно-ориентированные паттерны соответствующего «вида» — это отношение и взаимодействие между классами и объектами. Стоит обратить внимание на то, что конечные классы и объекты, используемые утилитой, не предопределяются.

### Преимущества и недостатки

Паттерны в Java – то, что поможет быстрее решать некоторые, наиболее распространенные задачи, с минимальными временными и силовыми затратами. Перед их внедрением в код стоит выяснить преимущества и недостатки инструментария.

### Плюсы

К сильным сторонам компонента относят следующие моменты:

1. Снижение сложности разработки. Достигается за счет наличия готовый абстракций для решения целого блока выявленных проблем.
2. Каждый шаблон дает алгоритму собственное имя. Это облегчает контакты между разрабами. Люди способны ссылаться на известные шаблоны без существенных трудностей.
3. Унификация деталей решений – модулей, элементов проекта. Это снижает количество ошибок при релизе.
4. Напоминает внедрение библиотек.

Если грамотно подобрать шаблон, можно пользоваться им для конкретной задачи снова и снова. Это экономит время и силы разработчика.

### Минусы

К слабым сторонам рассматриваемого объекта коддинга относят:

1. Усложнение приложения. Это происходит, если программер слепо следует установленному «макету».
2. Желание попробовать конкретный шаблон без реальных оснований. Это – не лучшее решение, которое способно довести кодификацию до критических ошибок, сбоев и неполадок.
3. Для того, чтобы софт функционировал предельно грамотно и правильно, нельзя использовать паттерны, дублируя их.

Стоит обратить внимание и на то, что любой шаблон проектирования может быть заменен разработчиком при помощи обычного программного кода.

## О типах

Все patterns можно разделить на несколько разновидностей. Они будут отвечать за примеры решений конкретных задач:

1. Порождающие. Представлены механизмами инициализации. Помогают создавать объекты удобными методами.
2. Структурные. Отвечают за определение отношений типа «класс-объект». Это дает возможность совместного взаимодействия и работы.
3. Поведенческие. Применяются тогда, когда необходимо справиться с упрощением взаимодействия между различными сущностями в кодификации.

![[DesignPatterns.webp]]

Pattern – достаточно удобный компонент, который требует вдумчивого и грамотного применения. Он, как и все остальные объекты программного кода, обладает сильными и слабыми сторонами.

### Порождающий тип

Объекты можно создавать при помощи паттернов. Но сначала требуется изучить «макеты», которые отвечают за инициализацию. К ним относят следующие разновидности:

1. [Singleton](Singleton). Носит название «Одиночка». Отвечает за ограничение создания одного экземпляра класса. Обеспечивает доступ к единственному объекту.
2. Abstract Factory – абстрактная фабрика. Супер фабрика используется для получения фабрики. После – оная применяется для организации объектов.
3. Factory – фабрика. Применяется тогда, когда есть суперкласс с несколькими подклассами. На основе ввода нужно вернуть один из подкласса.
4. [Builder](Builder). Называется «Строитель». Применяется для создания сложного объекта с использованием простых объектов. Он со временем отвечает за появление большего компонента от малого и простого.
5. Prototype – прототип. Шаблон, который создает дублированный объект с большей производительностью. Вместо нового создается возвращаемый клон существующего элемента.

И это – только начало. Юзерам предстоит разобраться в других вариантах шаблонов.

### Структурный тип

В книге Head First Patterns обязательно рассматривается структурный тип:

1. [Adapter](Adapter). Конвертер между несовместимыми объектами. Через него можно объединить интерфейсы, которые изначально не соединяются.
2. Composite. Компоновщик, отвечающий за использование одного класса для представление древовидной структуры.
3. Proxy. Это – заместитель. Дает функциональность другого класса.
4. Flyweight. Легковес. Вместо того, чтобы использовать большое количество схожих между собой объектов, они применяются повторно.
5. Facade. Обеспечивает элементарный интерфейс для клиентов. Юзеры будут применять его для контактирования с системой.
6. Bridge. Мост, который делает определенные классы независимыми от тех, что используются при реализации интерфейсов.
7. [Decorator](Decorator). Это – способ обеспечения новых функциональных возможностей существующего компонента кода. Его структура в ходе операций не будет привязываться.

### Поведенческий тип

Последняя категория шаблонов предусматривает такие варианты:

1. Template Method. Определяет основу алгоритма. Дает шанс наследникам переопределять часть алгоритмических шагов. Структура оных не будет корректироваться.
2. Mediator. Дает возможность предоставления класса посредника. Он будет обрабатывать все коммуникации между разными classes.
3. Chain of Responsibility. Не дает столкнуться с жесткой зависимостью отправителя запроса от его получателя. Сам запрос будет обрабатываться несколькими объектами.
4. Observer. С ним одни компоненты следят и реагируют на события с другими.
5. Strategy. Стратегия может корректироваться во время исполнения исходной кодификации.
6. Command. Команда, которая объявляет метод для проделывания конкретной манипуляции.
7. State. Поведение элемента корректируется в зависимости от его состояния.
8. Visitor. Упрощает операции над группированием связанных объектов.
9. Interpreter. Контролирует грамматику простого языка в зоне обнаруженной проблемы.
10. Iterator. Последовательно предоставляет доступ к компонентам элемента коллекции. Система не знает его ключевого представления.
11. Memento. Так называется шаблон-хранитель. Применяется тогда, когда нужно сохранить состояние объекта. Позже оно должно быть восстановлено приложением.

