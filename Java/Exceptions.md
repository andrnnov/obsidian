#Java #Exception
### Исключения ###

**Исключение** — это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:
1. Пользователь ввел некорректные данные.
2. Файл, к которому обращается программа, не найден.
3. Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.

Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

В языке Java исключения могут генерироваться одним из двух способов:

- _автоматически_. В этом случае исключения генерируются исполнительной системой Java. К таким исключениям входят ошибки, которые понимают правила языка Java или ограничения, которые накладываются системой;
- _вручную_. В этом случае исключения генерируются в программном коде, который разрабатывается. Ручные исключения программируются для сообщения вызывающему коду о возможных ошибках в методах разрабатываемой программы.
#### Иерархия исключений ####

![[exceptionsInJavaHierarchy.png]]
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.

1. **Error — это тип ошибок, которые выходят за рамки вашей программы, их невозможно предвидеть или обработать**. Это может быть аппаратный сбой, «поломка» JVM или ошибка памяти. Именно для таких необычных ситуаций есть отдельная иерархия ошибок. Мы должны просто знать, что такие ошибки есть и не можем справиться с такими ситуациями. Примеры `Error`: `OutOfMemoryError` и `StackOverflowError`.
2. **Проверяемые исключения (Checked Exceptions)** — тип исключений, которые мы можем предвидеть в программе и попытаться обработать, например, `FileNotFoundException`. Мы должны поймать это исключение и написать внятное и полезное сообщение пользователю о том, что произошло (также желательно логировать ошибки). `Exception` — родительский класс всех проверяемых исключений (**Checked Exceptions**). Если мы бросили проверяемое исключение, то должны поймать его в том же методе или должны пробросить его с помощью ключевого слова `throws`.
3. **Runtime Exception** — это ошибки программиста. Например, пытаясь получить элемент из массива, мы должны проверить длину массива, прежде чем пытаться получить элемент — в противном случае это может быть брошен `ArrayIndexOutOfBoundException`. `RuntimeException` — родительский класс для всех Runtime исключений. Если мы сами бросаем Runtime Exception в методе, то не обязательно указывать в сигнатуре метода ключевое слово `throws`.
####  Полезные методы в обработке исключений ####

Класс `Exception` и все его подклассы не содержат какие-либо методы для обработки исключений. Все предоставляемые методы находятся в базовом классе `Throwable`. Подклассы класса `Exception` созданы для того, чтобы определять различные виды исключений. Именно поэтому при обработке исключений мы можем легко определить причину и обработать исключение в соответствии с его типом.

Полезные методы класса `Throwable`:
1. **public String getMessage()** — этот метод возвращает сообщение, которое было создано при создании исключения через конструктор.
2. **public String getLocalizedMessage()** — метод, который переопределяют подклассы для локализации конкретное сообщение об исключении. В реализации `Throwable` класса этот метод просто использует метод `getMessage()`, чтобы вернуть сообщение об исключении (`Throwable` на вершине иерархии — ему нечего локализировать, поэтому он вызывает `getMessage())`.
3. Метод **StackTraceElement[] getStackTrace()** - возвращает массив, содержащий поэлементную трассировку стека в виде объектов класса `StackTraceElement`.
4. Метод **printStackTrace()** - выводит трассировку стека.
5. Метод **Throwable fillInStackTrace()** - возвращает объект класса `Throwable`, содержащий полную трассировку стека. Этот объект может быть сгенерирован повторно.
6. **public synchronized Throwable getCause()** — этот метод возвращает причину исключения или идентификатор в виде `null`, если причина неизвестна.
7. **public String toString()** — этот метод возвращает информацию о `Throwable` в формате `String`.
8. **public void printStackTrace()** — этот метод выводит информацию трассировки стека в стандартный поток ошибок, этот метод перегружен и мы можем передать `PrintStream` или `PrintWriter` в качестве аргумента, чтобы написать информацию трассировки стека в файл или поток.
#### Пример использования некоторых методов класса Throwable ####

Объявляется класс MyException, унаследованный от класса Exception. В иерархии классов исключений Java класс Exception унаследован от класса Throwable. Поэтому, класс MyException может использовать и переопределять методы класса Throwable.
```java
import java.util.Scanner;

// собственный класс исключения, унаследован от Exception
class MyException extends Exception
{
  // переопределенная функция getLocalizedMessage()
  public String getLocalizedMessage()
  {
    return "MyException.getLocalizedMessage()";
  }
}

// класс, содержащий функцию main()
public class Train04 {
  // функция main() тестирует работу класса MyException
  public static void main(String[] args) {
    // Ввести число x. Если число за пределами [0..100],
    // то сгенерировать исключение MyException
    int x;
    Scanner sc = new Scanner(System.in);
    System.out.print("x = ");
    x = sc.nextInt(); // ввести x

    try {
      // сгенерировать исключение (создать объект типа MyException),
      // если x за пределами [0..100]
      if ((x<0)||(x>100))
        throw new MyException();
      System.out.println("OK!");
    }
    catch(MyException e)
    {
      // обработка исключения типа MyException,
      // демонстрация некоторых методов класса Throwable
      System.out.println("Return from getLocalizedMessage(): " + e.getLocalizedMessage());
      System.out.println("Return from getMessage(): " + e.getMessage());
      System.out.println("Method printStackTrace(): ");
      e.printStackTrace();
      System.out.println("Method toString(): " + e.toString());
      System.out.println("------------------------");
      System.out.println("Method getStackTrace(). Stack trace: ");
      StackTraceElement[] stE;

      stE = e.getStackTrace(); // метод getStackTrace()

      for (int i=0;i<stE.length;i++)
        System.out.println(stE[i].toString());

      System.out.println("-------------------------");
      System.out.println("Method fillStackTrace(). Stack trace: ");

      Throwable tA = e.fillInStackTrace();
      StackTraceElement[] stE2 = tA.getStackTrace();

      for (int i=0; i<stE2.length; i++)
        System.out.println(stE[i].toString());
      System.out.println("-------------------------");
    }
  }
}
```
Объясним некоторые фрагменты кода.

С целью демонстрации в классе MyException переопределяется метод getLocalizedMessage(). При вызове этого метода выводится сообщение из этого переопределенного метода. По данному примеру можно переопределять другие методы класса Throwable.

В функции main() продемонстрировано использование методов класса Throwable. Вводится переменная **x**, которая проверяется на допустимые значения в пределах то 0 до 100. Если значение **x** меньше 0 или больше 100, то генерируется исключение типа MyException.

Результат работы программы
<p style="background-color: navy; color: yellow">
x = 200<br>
Return from getLocalizedMessage(): MyException.getLocalizedMessage()<br>
Return from getMessage(): null<br>
Method printStackTrace():<br>
Method toString(): MyException: MyException.getLocalizedMessage()<br>
------------------------<br>
Method getStackTrace(). Stack trace:<br>
Train04.main(Train04.java:36)<br>
-------------------------<br>
Method fillStackTrace(). Stack trace:<br>
Train04.main(Train04.java:36)<br>
-------------------------<br>
MyException: MyException.getLocalizedMessage()</p>

#### Перечень подклассов непроверяемых исключений из пакета java.lang ####

Среди всего разнообразия классов и интерфейсов пакет java.lang содержит мощный арсенал классов для обработки исключений. Эти классы и интерфейсы составляют основу всех программ на Java. Пакет java.lang автоматически импортируется во все программы.

Ниже приведен перечень подклассов непроверяемых исключений производными от класса RuntimeException и которые определены в пакете java.lang:
- ArithmeticException – арифметическая ошибка (например, деление на ноль);
- ArrayIndexOutOfBoundsException – индекс за пределами массива;
- ArrayStoreException – присваивание элементу массива объекта несовместимого типа;
- ClassCastException – неправильное приведение типов;
- EnumConstantNotPresent – попытка воспользоваться неопределенным значением перечисления;
- IllegalArgumentException – недопустимый аргумент при вызове метода;
- IllegalMonitorStateException – недопустимая контрольная операция;
- IllegalStateException – неверное состояние среды или приложения;
- IllegalThreadStateException – несовместимость запрашиваемой операции с текущим состоянием потока выполнения;
- IndexOutOfBoundsException – выход индекса некоторого типа за допустимые границы;
- NegativeArraySizeException – создание массива отрицательного размера;
- NullPointerException – неправильное использование пустой ссылки;
- NumberFormatException – неправильное преобразование символьной строки в числовой формат;
- SecurityException – попытка нарушения безопасности;
- StringIndexOutOfBounds – попытка доступа по индексу за пределами символьной строки;
- TypeNotPresentException – тип не найден;
- UnsupportedOperationException – найдена неподдерживаемая операция.
#### Проверяемые исключения из пакета java.lang ####

Если тип сгенерированного исключения не является подклассом стандартного класса RuntimeException, то это исключение называется проверяемым исключением. В случае генерирования такого типа исключения, его обязательно нужно включать в оператор throws метода.

В языке Java в пакете java.lang реализован ряд проверяемых исключений. Ниже приведен их перечень:
- ClassNotFoundException – класс не найден;
- CloneNotSupportedException – попытка клонировать объект из класса, который не реализует интерфейс Cloneable;
- IllegalAccessException – запрещен доступ к классу;
- InstantiationException – попытка создать объект абстрактного класса или интерфейса;
- InterruptedException – один поток выполнения прерван другим потоком;
- NoSuchFieldException – запрашиваемое поле не существует;
- NoSuchMethodException – запрашиваемый метод не существует;
- ReflectiveOperationException – суперкласс исключений, связанных с рефлексией.
Также, в перечень исключений оператора throws обязательно нужно включать собственноручно разработанные классы исключений для их проверки.

В Java есть пять ключевых слов для работы с исключениями:
1. **try** — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
2. **catch** — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
3. **finally** — ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока ‘catch’. Управление обычно передаётся в блок ‘finally’ в любом случае.
4. **throw** — служит для генерации исключений.
5. **throws** — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.
```java
import java.io.FileNotFoundException;
import java.io.IOException;

public class ExceptionHandling {
    // в методе main() пробрасывается сразу несколько исключений
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // в блоке try-catch перехватываются сразу несколько исключений 
        // вызовом дополнительного catch(...)
        try{
            testException(-5);
            testException(-10);
        }catch(FileNotFoundException e){
            e.printStackTrace();
        }catch(IOException e){
            e.printStackTrace();
        }finally{
            System.out.println("Необязательный блок, но раз уже написан, то выполнятся будет не зависимо от того было исключение или нет");          
        }
        testException(15);
    }
    
    // тестовый метод создания, обработки и пробрасывания исключения
    public static void testException(int i) throws FileNotFoundException, IOException{
        if(i < 0){
            FileNotFoundException myException = new FileNotFoundException("число меньше 0: " + i);
            throw myException;
        }else if(i > 10){
            throw new IOException("Число должно быть в пределах от 0 до 10");
        }
    }
}
```
А в консоле эта программа напишет такое:
<p style="background-color: navy; color: yellow">
java.io.FileNotFoundException: число меньше 0: -5<br>
    at ExceptionHandling.testException(ExceptionHandling.java:24)<br>
    at ExceptionHandling.main(ExceptionHandling.java:10)<br>
Необязательный блок, но раз уже написан, то выполнятся будет не зависимо от того было исключение или нет<br>
Exception in thread "main" java.io.IOException: Число должно быть в пределах от 0 до 10<br>
    at ExceptionHandling.testException(ExceptionHandling.java:27)<br>
    at ExceptionHandling.main(ExceptionHandling.java:19)</p>

Обратите внимание, что метод `testException()` бросает исключение, используя ключевое слово `throw`, а в сигнатуре метода используется ключевое слово `throws`, чтобы дать понять вызывающему методу тип исключений, которые может бросить `testException()`.

**Важные моменты в обработке исключений:**
- Нельзя использовать блоки `catch` или `finally` без блока `try`.
- Блок `try` также может быть использован только с `catch` блоком, или только с `finally` блоком, или с тем и другим блоком.
- Мы можем использовать несколько блоков `catch` только с одним `try`.
- `try-catch` блоки могут быть вложенными — этим они очень похожи на `if-else` конструкции.
- Мы можем использовать только один, блок `finally` в одном `try-catch`.

Стандартный обработчик исключений Java вызывается в случаях, когда программа:
- не использует блок try…catch для обработки и перехвата исключительной ситуации вообще;
- содержит блок try…catch, однако в этом блоке данный тип исключения не перехватывается.

Если программа содержит собственный код try…catch для обработки данной исключительной ситуации, тогда стандартный обработчик исключений не вызывается.
#### Автоматическое управление ресурсами и улучшения блока перехвата ошибок в Java 7 ####

Если вам нужно перехватывать много исключений в одном блоке `try-catch`, то блок перехвата будет выглядеть очень некрасиво и в основном будет состоять из избыточного кода. Именно поэтому в Java 7 это было значительно улучшено и теперь мы можем перехватывать несколько исключений в одном блоке `catch`.

Это выглядит следующим образом:
```Java
catch(IOException | SQLException | Exception ex){
     //что-то сделать с перехваченной ошибкой...
}
```
#### Создание своих классов исключений ####

Java предоставляет много классов исключений, но иногда нам может понадобиться создать свои «кастомные» классы исключений. Это может понадобиться для того, чтобы уведомить абонента о конкретном типе исключения с соответствующим сообщением. Например, мы напишем метод для обработки только текстовых файлов, поэтому мы можем написать свой класс исключений и передавать соответствующий код ошибки, когда кто-то передает неподходящий тип файла в качестве входных данных.

Вот пример своего класса исключений и его использование:
```java
// наследуемся от класс Exception
public class MyException extends Exception {
    private String errorCode = "Unknown_Exception";
    public MyException(String message, String errorCode){
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode(){
        return this.errorCode;
    }
}
```
А теперь проверим в работе наш класс MyException:
```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class CustomExceptionExample {
    public static void main(String[] args) throws MyException {
        try {
            processFile("file.txt");
        } catch (MyException e) {
            processErrorCodes(e);
        }
    }

    // метод для обработки ошибок
    private static void processErrorCodes(MyException e) throws MyException {
	        // здесь мы ищем указанный при выбросе исключения код ошибки и 
	        // сообщаем пользователю что произошло

        switch(e.getErrorCode()){
        case "BAD_FILE_TYPE":
            System.out.println("Неподходящий тип файла");
            throw e;
        case "FILE_NOT_FOUND_EXCEPTION":
            System.out.println("Файл не найден");
            throw e;
        case "FILE_CLOSE_EXCEPTION":
            System.out.println("Ошибка при закрытии файла");
            break;
        default:
            System.out.println("Произошла неизвестная ошибка " + e.getMessage());
            e.printStackTrace();
        }
    }

    // метод для работы с файлом, который пробрасывает наш тип исключений
    private static void processFile(String file) throws MyException {      
        InputStream fis = null;
        try {
            fis = new FileInputStream(file);
        } catch (FileNotFoundException e) {
            // здесь мы бросаем исключение с указанием кода ошибки
            throw new MyException(e.getMessage(),"FILE_NOT_FOUND_EXCEPTION");
        }finally{
            try {
                if(fis !=null)fis.close();
            } catch (IOException e) {
                // здесь мы бросаем исключение с указанием кода ошибки
                throw new MyException(e.getMessage(),"FILE_CLOSE_EXCEPTION");
            }
        }
    }
}
```
#### Полезные советы по обработке исключений в Java ####

1. **Не используйте для перехвата исключений класс `Exception`**. В иерархии исключений есть множество классов на все случаи жизни вашей программы, которые не только эффективно обработают конкретную ошибку, но и предоставят полезную для пользователя и отладки информацию.
2. **Бросайте исключение как можно раньше.** Это является хорошей практикой программирования на Java.
3. Ловите исключения только тогда, когда сможете эффективно для пользователя и отладки их обработать.
4. **Освобождайте ресурсы**. Перехватывая исключение всегда закрывайте открытые ресурсы. Еще проще и эффективнее это делать с `Java 7`. Используйте try с ресурсами для лаконичного и красивого кода.
5. **Логируйте исключения.** Логируйте сообщения, которые предоставляет исключение. В большинстве случаев это даст вам четкое понимание причин и поможет в отладке. Не оставляйте пустым блок `catch`, иначе он будет просто поглощать исключение без каких-либо значимых деталей для отладки.
6. **Один catch для нескольких исключений**. Используйте преимущества Java 7 для удобства и красоты вашего кода.
7. **Используйте свои исключения**. Это позволит вам лучше чувствовать свою программу и эффективнее с ней работать.
8. **Соглашения об именовании**. Когда вы создать свои классы исключений, следите за тем, что из самого названия класса будет ясно, что это исключение.
9. **Используйте исключения с умом**. Бросить исключение — достаточно дорогостоящая в Java операция. Возможно, в некоторых случаях будем уместно не бросать исключений, а вернуть, например, логическую переменную, которая обозначала успешное или не успешное выполнение метода.
10. **Документируйте исключения**. Желательно писать javadoc @throws для ваших исключений. Это будет особенно полезно в тех случаях, когда ваша программа предоставляет интерфейс для работы с другими приложениями.
