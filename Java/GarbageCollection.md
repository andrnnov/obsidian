#java #JVM #GarbageCollection
## Сборка мусора в Java

2024-11-21 16:30

### Что такое сборка мусора, зачем она нужна и как работает

Для работы любого приложения требуется память. Однако память компьютера ограничена. Поэтому важно ее очищать от старых неиспользуемых данных, чтобы освободить место для новых.

Кто занимается этой очисткой? Как и когда очищается память? Как выглядит структура памяти? Давайте разберем с этим подробнее.

### Структура памяти Java

Память в Java состоит из следующих областей:
![[GarbageCollection1.png]]

**Native Memory** — вся доступная системная память.

**Heap (куча)** — часть native memory, выделенная для кучи. Здесь JVM хранит объекты. Это общее пространство для всех потоков приложения. Размер этой области памяти настраивается с помощью параметра -Xms (минимальный размер) и -Xmx (максимальный размер).

**Stack (стек)** — используется для хранения локальных переменных и стека вызовов метода. Для каждого потока выделяется свой стек.

**Metaspace (метаданные)** — в этой памяти хранятся метаданные классов и статические переменные. Это пространство также является общими для всех. Так как metaspace является частью native memory, то его размер зависит от платформы. Верхний предел объема памяти, используемой для metaspace, можно настроить с помощью флага MaxMetaspaceSize.

**PermGen** (Permanent Generation, постоянное поколение) присутствовало до Java 7. Начиная с Java 8 ему на смену пришла область Metaspace.

**CodeCache (кэш кода)** — JIT-компилятор компилирует часто исполняемый код, преобразует его в нативный машинный код и кеширует для более быстрого выполнения. Это тоже часть native memory.

### Сборка мусора: введение

Что такое "мусор"? Мусором считается объект, который больше не может быть достигнут по ссылке из какого-либо объекта. Поскольку такие объекты больше не используются в приложении, то их можно удалить из памяти.

Например, на диаграмме ниже объект fruit2 может быть удален из памяти, поскольку на него нет ссылок.
![[GarbageCollection2.png]]

Что такое сборка мусора? Сборка мусора — это процесс автоматического управления памятью. Освобождение памяти (путем очистки мусора) выполняется автоматически специальным компонентом JVM — сборщиком мусора (Garbage Collector, GC). Нам, как программистам, нет необходимости вмешиваться в процесс сборки мусора.
![[GarbageCollection3.png]]

### Сборка мусора: процесс

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

1. **Mark (маркировка)**. На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .
    
2. **Sweep (очистка)**. На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
    
3. **Compact (уплотнение)**. Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

![[GarbageCollection4.png]]

### Поколения объектов

#### Что такое поколения объектов?

Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области. В эти области объекты помещаются в зависимости от их возраста (как долго они используются в приложении).

1. **Young Generation (молодое поколение)**. Здесь создаются новые объекты. Область young generation разделена на три части раздела: Eden (Эдем), S0 и S1 (Survivor Space — область для выживших).
    
2. **Old Generation (старое поколение)**. Здесь хранятся давно живущие объекты.
![[GarbageCollection5.png]]

#### Что такое Stop the World?

Когда запускается этап mark, работа приложения останавливается. После завершения mark приложение возобновляет свою работу. Любая сборка мусора — это "Stop the World".

#### Что такое гипотеза о поколениях?

Как уже упоминалось ранее, для оптимизации этапов mark и sweep используются поколения. Гипотеза о поколениях говорит о следующем:

1. Большинство объектов живут недолго.
    
2. Если объект выживает, то он, скорее всего, будет жить вечно.
    
3. Этапы mark и sweep занимают меньше времени при большом количестве мусора. То есть маркировка будет происходить быстрее, если анализируемая область небольшая и в ней много мертвых объектов.
    

Таким образом, алгоритм сборки мусора, использующий поколения, выглядит следующим образом:
![[GarbageCollection6.png]]

1. Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые.
    
2. Когда область Eden заполняется, происходит **минорная сборка мусора (Minor GC)**. Minor GC — это процесс, при котором операции mark и sweep выполняются для young generation (молодого поколения).
    
3. После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью удаляются.
    
4. По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты перемещаются в область S1, и их возраст увеличивается (отметка о том, что они пережили сборку мусора).
    
5. При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются.
    
6. Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old.
    
7. Major GC. При **Major GC** этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с Minor GC, поскольку старое поколение в основном состоит из живых объектов.

#### Преимущества использования поколений

Minor GC происходит в меньшей части кучи (~ 2/3 от кучи). Этап маркировки эффективен, потому что область небольшая и состоит в основном из мертвых объектов.

#### Недостатки использования поколений

В каждый момент времени одно из пространств Survivor (S0 или S1) пустое и не используется.

### Типы GC в JVM

### Serial Garbage Collector

Serial GC работает в однопоточном режиме, что означает, что во время сборки мусора все другие потоки приложения приостанавливаются (Stop-The-World пауза). Это самый простой и базовый сборщик мусора в JVM, без дополнительных сложностей многопоточной обработки или параллельной сборки мусора.

Когда Serial GC начинает процесс сборки мусора, он останавливает все другие потоки в приложении. Это означает, что выполнение приложения полностью приостанавливается на время сборки мусора.

Serial GC начинает с процесса маркировки, который определяет, какие объекты в куче все еще используются и должны быть сохранены. Он обходит все объекты, доступные из корневого набора ([root set](https://www.ibm.com/docs/en/ztpf/2020?topic=collector-root-set)), который включает в себя глобальные переменные, активные потоки и т.д., маркируя каждый достижимый объект.

После маркировки GC удаляет все немаркированные объекты, освобождая занимаемую ими память. Это процесс называется _очисткой_.

В некоторых случаях, особенно если в куче много фрагментированной памяти, Serial GC может выполнить уплотнение. Это процесс, в ходе которого оставшиеся объекты перемещаются в непрерывный блок, что уменьшает фрагментацию памяти и упрощает последующее выделение памяти.

Не смотря на свою простоту и эффективность в средах с ограниченными ресурсами, SGC имеет ряд существенных недостатков.

Stop-The-World паузы могут быть проблематичными для приложений, требующих высокой отзывчивости или непрерывной работы.

Не подходит для многопроцессорных или многопоточных приложений, где требуется более высокая пропускная способность.

### Parallel Garbage Collector (Throughput Collector)

Parallel GC использует несколько потоков для выполнения задач GC, что позволяет эффективно использовать многопроцессорные системы. Основная цель - максимизация пропускной способности приложения, то есть максимальное количество работы, которое приложение может выполнить за единицу времени.

Как и Serial GC, Parallel GC также инициирует Stop-The-World паузы. Во время этих пауз все потоки приложения приостанавливаются для выполнения задач GC.

В этой фазе GC идентифицирует все живые объекты в куче. Это достигается путём обхода всех объектов, начиная с корневого набора (который включает в себя глобальные переменные и активные потоки). Многопоточность используется для ускорения процесса обхода и маркировки.

После того как "живые" объекты определены, GC удаляет недоступные объекты, тем самым освобождая память. Эта фаза также может выполняться многопоточно для ускорения процесса.

В некоторых случаях может проводиться уплотнение памяти для уменьшения фрагментации. Это включает перемещение живых объектов так, чтобы они занимали непрерывный блок памяти. Уплотнение улучшает последующее выделение памяти, но может увеличить время паузы GC.

PGC позволяет нам добиться улучшенной производительности на многопроцессорных и многопоточных системах. Но не смотря на это возможны более длительные Stop-The-World паузы по сравнению с более специализированными сборщиками мусора.

Резюмируя - не всегда идеален для приложений, где критично время отклика.

### Concurrent Mark-Sweep (CMS) Collector

CMS спроектирован для выполнения большей части своих задач одновременно с работой приложения, что минимизирует паузы, связанные с GC. Работа CMS делится на две основные фазы: фазу маркировки (Marking Phase) и фазу очистки (Sweeping Phase).

**Фаза предварительной очистки (Initial Mark):**

Это короткая Stop-The-World пауза, во время которой CMS маркирует корневые объекты, то есть объекты, доступные непосредственно из потоков приложения, глобальных переменных и т.д. Эта фаза быстра, но требует остановки всех потоков приложения.

**Конкурентная фаза маркировки (Concurrent Marking):**

В этой фазе, CMS продолжает процесс маркировки, обходя все объекты, достижимые из корневых объектов. Эта работа выполняется параллельно с выполнением приложения. Во время этой фазы приложение продолжает работать, что снижает влияние GC на время отклика приложения.

**Фаза перемаркировки (Remark):**

Это ещё одна короткая Stop-The-World пауза, во время которой CMS исправляет любые изменения, сделанные в куче после начала фазы конкурентной маркировки. Для оптимизации этого процесса часто используется алгоритм "снимка" (Snapshot-At-The-Beginning), который отслеживает изменения, произошедшие в куче с момента начала маркировки.

**Конкурентная фаза очистки (Concurrent Sweeping):**

После завершения маркировки, CMS удаляет немаркированные, а значит, недоступные объекты. Этот процесс также происходит параллельно с выполнением приложения. В результате, освобождается память, занимаемая недоступными объектами.

CMS обычно выбирают для серверных приложений и приложений в реальном времени, где важнее минимизировать время остановки, чем максимизировать пропускную способность или оптимизировать использование памяти. Однако, следует учитывать нагрузку на процессор и потенциальные проблемы с фрагментацией памяти, которая может быть из-за отсутствия уплотнения по умолчанию.

### G1 Garbage Collector

G1 (Garbage-First) Garbage Collecto отличается от традиционных подходов, таких как CMS или Parallel GC, своей способностью более эффективно управлять системными ресурсами.

G1 GC разделяет кучу на множество небольших областей (регионов), что позволяет более гибко управлять памятью. Эти регионы могут быть различных типов, включая _Eden_, _Survivor_, и _Old_. G1 GC приоритизирует сборку мусора в тех регионах, где это наиболее эффективно, основываясь на объеме мусора и затратах на его очистку.

Как и в CMS, G1 начинается с короткой Stop-The-World паузы для маркировки корневых объектов. Это включает в себя объекты, которые непосредственно доступны из потоков приложения, статические объекты и т.д.

G1 продолжает процесс маркировки, обходя все объекты, доступные из корневых объектов, параллельно с выполнением приложения. В это время приложение продолжает работать, что снижает влияние GC на время отклика.

Далее идет фаза _Final Mark,_ включает еще одну короткую Stop-The-World паузу, во время которой G1 завершает процесс маркировки. В эту фазу включается обработка изменений, которые произошли в куче с момента начала конкурентной маркировки.

В последней фазе (сборке мусора) G1 собирает мусор из отдельных регионов. Это может включать перемещение живых объектов из одного региона в другой. Эта фаза также является Stop-The-World паузой, но ее длительность более предсказуема и обычно короче, чем в традиционных GC.

G1 Garbage Collector подходит для приложений с большим объемом кучи, где важны как производительность, так и предсказуемое время остановки. Он идеально подходит к примеру для серверных приложений.

### Z Garbage Collector (ZGC) и Shenandoah

Z Garbage Collector (ZGC) и Shenandoah предназначены для минимизации Stop-The-World (STW) пауз, что является маст хевом для приложений с требованиями к низкой задержке.

#### ZGC

ZGC разделяет кучу на набор мелких регионов. Это позволяет собирать мусор в каждом регионе независимо, что уменьшает время STW пауз. ZGC начинается с конкурентной фазы маркировки, которая происходит параллельно с работой приложения, минимизируя задержки.

Одной из ключевых особенностей ZGC является его способность к конкурентной релокации объектов. Это означает, что он может перемещать объекты во время работы приложения, что снижает необходимость в длительных STW паузах.

ZGC эффективно управляет фрагментацией памяти, регулярно уплотняя кучу во время работы приложения. ZGC использует цветные указатели и специальные барьеры чтения/записи для отслеживания доступных и перемещенных объектов, что позволяет оптимизировать процесс сборки мусора.

#### Shenandoah

Аналогично ZGC, Shenandoah выполняет большую часть работы по маркировке и компактизации конкурентно, то есть параллельно с выполнением приложения.

Shenandoah стремится минимизировать STW паузы, необходимые для некоторых задач сборки мусора. Shenandoah использует барьеры на пути выполнения для отслеживания доступа к объектам и их перемещения, что позволяет приложению продолжать работу во время сборки мусора.

Как и ZGC, Shenandoah активно управляет фрагментацией в куче, регулярно уплотняя пространство для эффективного выделения памяти.

Оба GC разработаны для обеспечения низких задержек в приложениях с большой кучей.

Подготовил небольшую обзорную табличку сравнения сборщиков:

|Сборщик Мусора|Преимущества|Недостатки|Идеален для|
|---|---|---|---|
|Serial GC|Простота, эффективность для малых приложений|Низкая производительность на многопроцессорных системах|Малые приложения, ограниченные ресурсы|
|Parallel GC|Высокая пропускная способность|Длинные паузы GC|Серверные приложения, многопроцессорные системы|
|CMS|Низкие паузы GC|Возможная фрагментация памяти, сложность|Интерактивные приложения|
|G1 GC|Баланс между производительностью и задержкой, масштабируемость|Может требовать тонкой настройки|Большие серверные приложения|
|ZGC/Shenandoah|Минимальные паузы|Новизна, потенциальные ограничения в использовании|Приложения с требованиями к ультранизкой задержке|

## Тюнинг и мониторинг

JVM предоставляет множество параметров для настройки GC, включая размеры начальной и максимальной кучи (`-Xms` и `-Xmx`), размеры поколений (например, `-XX:NewSize`), а также выбор конкретного сборщика мусора (например, `-XX:+UseG1GC` для G1 GC).

Правильная настройка параметров GC зависит от характеристик приложения и доступных системных ресурсов. Например, увличение размера кучи может уменьшить частоту сборки мусора, но также может увеличить продолжительность каждой STW паузы.

[Флаги JVM](https://www.baeldung.com/jvm-tuning-flags) и переменные среды используются для тонкой настройки поведения GC, такие как управление поведением различных поколений объектов и настройка порогов для запуска сборки мусора.

JVM позволяет включить детальное логирование событий GC, что дает информацию о времени и продолжительности каждой сборки мусора, а также о количестве освобожденной памяти. Существуют различные инструменты для мониторинга работы GC в реальном времени, такие как [VisualVM](https://visualvm.github.io/), [JConsole](https://docs.oracle.com/javase/8/docs/technotes/guides/management/jconsole.html) или интегрированные средства мониторинга в различных IDE. Эти инструменты предоставляют визуализацию использования памяти и активности GC.

Анализ данных мониторинга и логов помогает выявить узкие места в производительности, связанные с управлением памятью, и дает понимание о том, как настройки GC влияют на поведение приложения.

## Оптимизация и настройка GC

Существует множество параметров, которые позволяют контролировать поведение GC, управлять использованием памяти и оптимизировать производительность приложения. Эти параметры могут быть установлены при запуске JVM и охватывают различные моменты работы сборщиков мусора:

1. `-Xms<size>` и `-Xmx<size>`:
    
    - Устанавливают начальный (`-Xms`) и максимальный (`-Xmx`) размер кучи.
        
    - Например, `-Xms512m -Xmx4g` устанавливает начальный размер кучи в 512 мегабайт и максимальный в 4 гигабайта.
        
2. `-XX:NewRatio=<ratio>`:
    
    - Определяет соотношение между старым и молодым поколением в куче.
        
    - Например, `-XX:NewRatio=2` означает, что старое поколение будет в два раза больше молодого.
        
3. `-XX:SurvivorRatio=<ratio>`:
    
    - Определяет соотношение между каждой из Survivor областей и Eden областью в молодом поколении.
        
    - Например, `-XX:SurvivorRatio=8` означает, что Eden будет в 8 раз больше каждой из Survivor областей.
        
4. `-XX:MaxTenuringThreshold=<value>`:
    
    - Устанавливает максимальное количество циклов сборки мусора, после которых объект из молодого поколения перемещается в старое.
        
    - Более низкое значение означает более быстрое перемещение объектов в старое поколение.
        
5. `-XX:+Use<Collector>`:
    
    - Указывает, какой сборщик мусора использовать. Например, `-XX:+UseG1GC`, `-XX:+UseParallelGC`, `-XX:+UseConcMarkSweepGC`.
        

#### Параметры для специфических сборщиков мусора

1. **Parallel GC:**
    
    - `-XX:ParallelGCThreads=<n>`: Устанавливает количество потоков для сборки мусора в Parallel GC.
        
2. **CMS (Concurrent Mark-Sweep):**
    
    - `-XX:CMSInitiatingOccupancyFraction=<percent>`: Указывает процент заполнения кучи, при котором начнется CMS cycle.
        
    - `-XX:+UseCMSInitiatingOccupancyOnly`: Указывает JVM использовать только заданный процент для начала CMS cycle.
        
3. **G1 GC:**
    
    - `-XX:MaxGCPauseMillis=<milliseconds>`: Целевое значение для максимальной длительности паузы GC.
        
    - `-XX:G1HeapRegionSize=<size>`: Устанавливает размер региона в G1 GC.
        
4. **ZGC:**
    
    - `-XX:ConcGCThreads=<n>`: Количество потоков, используемых для параллельной обработки в ZGC.
        
5. **Shenandoah:**
    
    - `-XX:ShenandoahGCHeuristics=<heuristic>`: Определяет эвристику, которую Shenandoah будет использовать.
        

Для мониторинга и профилирования GCC используются различные инструменты, включая VisualVM, JConsole и логи GC:

### VisualVM

VisualVM – это мощный инструмент для визуального мониторинга, диагностики и профилирования Java-приложений.

VisualVM позволяет отслеживать использование CPU, памяти и потоков в реальном времени. Инструмент предоставляет информацию о состоянии кучи (heap) и событиях сборки мусора, включая время пауз и частоту GC.

Позволяет идентифицировать "узкие места" в коде, анализировать использование памяти и производительность потоков.

### JConsole

JConsole – это инструмент Java Monitoring and Management Console, который используется для мониторинга и управления приложениями Java.

Позволяет отслеживать использование памяти, загрузку CPU и активность потоков. Позволяет визуализировать использование различных областей памяти и возможность инициирования сборки мусора. Отображает информацию о Java-среде, включая версию, конфигурацию и библиотеки.

Подключается к JMX (Java Management Extensions) агенту для сбора данных о работе Java-приложения.

### GC Logs

Логи GC – это файлы журналов, которые содержат подробную информацию о процессах сборки мусора в JVM.

Предоставляют информацию о времени начала и окончания каждой сборки мусора, а также о том, какие области памяти были очищены. Помогают идентифицировать потенциальные утечки памяти и неэффективное использование памяти.

Позволяют анализировать производительность GC в течение длительного времени.

Включение логирования GC производится с помощью флагов командной строки при запуске JVM, например, `-Xlog:gc`, `-Xlog:gc*` для Java 9+ или `-XX:+PrintGCDetails` для старых версий.

Утечки памяти, задержки и другие проблемы, связанные с производительностью и управлением памятью, являются распространенными трудностями при работе с Java-приложениями:

### Утечки памяти

Утечки памяти происходят, когда объекты, которые больше не нужны приложению, по каким-то причинам не удаляются Garbage Collector'ом (GC), продолжая занимать память.

### Причины:

**Неправильное управление ресурсами:** Например, не закрытые соединения или потоки.

**Статические коллекции:** Статические переменные, сохраняющие ссылки на объекты.

**Листенеры и коллбеки:** Объекты, зарегистрированные в качестве слушателей или коллбеков, и не отмененные должным образом.

### Решения:

- **Профилирование памяти:** Использование инструментов, таких как VisualVM или JProfiler, для обнаружения объектов, которые занимают большую часть памяти и не освобождаются.
    
- **Анализ кода:** Поиск потенциальных утечек памяти, особенно в статических полях и коллекциях.
    
- **Использование Weak References:** Использование слабых ссылок для объектов, которые могут быть освобождены GC.
    
- **Правильное управление ресурсами:** Закрытие всех ресурсов (соединения, потоки) в блоках `finally` или с помощью конструкций [try-with-resources](try-with-resources).
    

### Задержки

Задержки, часто связанные с процессами GC, влияют на время отклика приложения.

### Причины:

1. **Чрезмерная активность GC:** Вызвана недостаточным объемом памяти или частым созданием объектов.
    
2. **Неподходящий выбор GC:** Использование GC, не подходящего для специфики приложения.
    

### Решения:

- **Оптимизация размера кучи:** Увеличение `-Xmx` и `-Xms` для предоставления большего объема памяти приложению.
    
- **Выбор подходящего GC:** Эксперименты с разными сборщиками мусора для определения оптимального.
    
- **Тюнинг GC:** Настройка параметров GC, например, `-XX:NewSize`, `-XX:MaxNewSize`, `-XX:SurvivorRatio`.
    

## Немного примеров настройки GC

Настройка сборщика мусора в Java Virtual Machine (JVM) обычно не включает написание кода, поскольку она осуществляется через параметры командной строки при запуске JVM. Однако, рассмотрим примеры, где проведем настройку gc через код:

#### Пример 1

Настроить GC для веб-серверного приложения, где приоритетом является минимизация времени остановки для низкой задержки.

**Код:**

```
java -XX:+UseG1GC -Xms4G -Xmx4G -XX:MaxGCPauseMillis=200 -jar my-web-app.jar
```

- `-XX:+UseG1GC`: Использование G1 GC, который подходит для приложений с большим объемом памяти и требующих низких пауз GC.
    
- `-Xms4G` и `-Xmx4G`: Установка начального и максимального размера кучи в 4 ГБ.
    
- `-XX:MaxGCPauseMillis=200`: Целевое значение для максимальной длительности паузы GC в 200 мс.
    

#### Пример 2

Настроить GC для приложения обработки больших данных, где важна общая пропускная способность и эффективность использования памяти.

**Код:**

```
java -XX:+UseParallelGC -Xms8G -Xmx8G -XX:ParallelGCThreads=8 -jar my-data-processing-app.jar
```

- `-XX:+UseParallelGC`: Использование Parallel GC, который эффективен для многопоточных систем.
    
- `-Xms8G` и `-Xmx8G`: Установка начального и максимального размера кучи в 8 ГБ.
    
- `-XX:ParallelGCThreads=8`: Установка количества потоков для Parallel GC, оптимизировано для многопроцессорных систем.
    

#### Пример 3

Настроить GC для настольного приложения с пользовательским интерфейсом, требующего коротких пауз GC для обеспечения плавности работы.

**Код:**

```
java -XX:+UseConcMarkSweepGC -Xms512M -Xmx512M -jar my-desktop-app.jar
```

- `-XX:+UseConcMarkSweepGC`: Использование CMS GC, который минимизирует время остановки приложения.
    
- `-Xms512M` и `-Xmx512M`: Установка начального и максимального размера кучи в 512 МБ, достаточно для многих настольных приложений.
    

#### Пример 4

Настроить GC для сервера приложений, обрабатывающего высокие нагрузки и требующего большого объема памяти и высокой пропускной способности.

**Код:**

```
java -XX:+UseG1GC -Xms16G -Xmx16G -XX:ConcGCThreads=10 -jar my-high-load-server-app.jar
```

- `-XX:+UseG1GC`: Использование G1 GC, который подходит для серверных приложений с большим объемом памяти.
    
- `-Xms16Gи-Xmx16G`: Установка начального и максимального размера кучи в 16 ГБ.
    
- `-XX:ConcGCThreads=10`: Настройка количества потоков для параллельной сборки мусора.
    

#### Пример 5

Настроить GC для приложения с критически важными требованиями к низкой задержке.

**Код:**

```
java -XX:+UseZGC -Xms4G -Xmx4G -jar my-low-latency-app.jar
```

- `-XX:+UseZGC`: Использование Z Garbage Collector, который предназначен для систем с ультранизкими задержками.
    
- `-Xms4G` и `-Xmx4G`: Установка начального и максимального размера кучи в 4 ГБ для управления большими объемами данных с минимальными паузами.
    

В заключение, правильное применение GC в JVM может значительно улучшить производительность приложений, снизить задержки, предотвратить утечки памяти и улучшить общее управление ресурсами. В конечном итоге, это приводит к созданию более надежных, эффективных и высокопроизводительных приложений, способных удовлетворять самые разнообразные требования и условия эксплуатации.


Ссылки на статьи:
1. [Избавляемся от мусора в Java](https://habr.com/ru/companies/otus/articles/553996/)

2. [Сборка мусора в Java: что это такое и как работает в JVM](https://vc.ru/dev/397062-sborka-musora-v-java-chto-eto-takoe-i-kak-rabotaet-v-jvm)

3. [Все типы сборщиков мусора в Java, о которых вы должны знать](https://javarush.com/groups/posts/4075-kofe-breyk-210-vse-tipih-sborjshikov-musora-v-java-o-kotorihkh-vih-dolzhnih-znatjh)

4. [Garbage Collection и JVM](https://habr.com/ru/companies/otus/articles/776342/)