#Java #interface 
## Интерфейсы - объявление и применение

2024-03-27 14:47

Рассмотрим задачу, где оправдано применение этих интерфейсов. Как всегда, предположим, что у нас есть [абстрактный базовый класс](AbstractInterface) Geom:
```java
abstract class Geom {
    int width, color;
    abstract void draw();
}
```
от которого наследуются дочерние классы графических примитивов:
```java
class Line extends Geom {
    void draw() {
        System.out.println("Рисование линии");
    }
}
 
class Rectangle extends Geom {
    void draw() {
        System.out.println("Рисование прямоугольника");
    }
}
 
class Triangle extends Geom {
    void draw() {
        System.out.println("Рисование треугольника");
    }
}
```
В итоге, у нас получится следующая иерархия. И здесь заказчик перед нами ставит задачу: реализовать методы для вычисления площадей этих фигур, но только у тех, для которых это имеет смысл. То есть, площадь у линии вычислять не нужно, а только у прямоугольника и треугольника.
![[HierarchyClass.png]]
Как это лучше всего сделать? Имея текущие знания, нам придется непосредственно в дочерних классах Rectangle и Triangle реализовать метод для вычисления площади, например, так:
```java
class Rectangle extends Geom {
    void draw() {
        System.out.println("Рисование прямоугольника");
    }
 
    public double getSquare() {
        return 5*10;
    }
}
 
class Triangle extends Geom {
    void draw() {
        System.out.println("Рисование треугольника");
    }
 
    public double getSquare() {
        return 0.5*4*10;
    }
}
```
Но в этом случае, у нас не будет общего интерфейса для обращения к этому методу. То есть, если в функции main мы создадим несколько примитивов:
```java
final int N = 3;
Geom g[] = new Geom[N];
g[0] = new Line();
g[1] = new Rectangle();
g[2] = new Triangle();
```
то, во-первых, через ссылки g[0], g[1], g[2] мы не сможем вызывать этот метод и, во-вторых, даже если привести эти ссылки к типу дочернего класса, то как узнать, что в нем существует метод getSquare?

Мы могли бы относительно легко решить эту задачу, если бы в Java было множественное наследование, т.е. один дочерний класс можно было бы образовывать от нескольких базовых. Тогда достаточно было бы прописать еще один класс, например, MathGeom и указать его в качестве базового у классов Rectangle и Triangle. Но такого функционала в Java нет.
![[HierarchyClass1.jpg]]
Как же все таки решить эту задачу? Здесь нам на помощь приходит еще одна конструкция ООП языка Java под названием **интерфейс**. Мы можем объявить MathGeom как интерфейс и подключить его к нужным нам классам.

Что же такое интерфейс и чем он отличается от классов? В целом, его можно воспринимать в виде абстрактного класса с набором, как правило, абстрактных методов (интерфейсов). Задается он ключевым словом interface, и в фигурных скобках идет список констант и методов:
```java
[модификатор доступа] interface <имя интерфейса> {  
       [константы;]  
       [методы;]  
}
```
Если модификатор доступа не указан, то интерфейс можно использовать всюду в рамках текущего пакета. Если указан модификатор public, то интерфейс доступен в любом месте программы (в любом пакете). Кроме того, при определении публичного интерфейса, он должен быть объявлен в отдельном файле, имя которого должно совпадать с именем интерфейса. То есть, здесь все так же как и при объявлении публичных классов.

Итак, ключевое отличие интерфейса от класса в том, что его цель предоставить общие абстрактные методы, которые, затем, определяются в отдельных, выбранных, классах. То есть, сам по себе интерфейс не реализует никакой логики (хотя может), он лишь позволяет описывать общие методы, реализуемые в нужных нам классах, независимо от иерархии наследования классов. А, затем, с помощью механизма динамической диспетчеризации, через интерфейс можно вызывать различные реализации его методов. И мы сейчас увидим как это делается.

В нашем случае MathGeom можно объявить как интерфейс, следующим образом:
```java
interface MathGeom {
    double getSquare();
}
```
В нем идет определение одного единственного метода без реализации (в конце стоит точка с запятой) и возвращаемый тип double. Обратите внимание, у нас перед ключевым словом interface не указан никакой модификатор доступа, значит, используется модификатор по умолчанию и, как мы уже говорили, в этом случае интерфейс доступен только в рамках текущего проекта. Далее, всем методам без реализации внутри интерфейса автоматически применяется модификатор public, т.к. цель таких методов – публичный доступ из любого места программы.

Отлично, это мы сделали. Теперь нужно «привязать» интерфейс к выбранным классам (или, как говорят, реализовать интерфейс в классе), так как сам по себе он не может быть использован. Например, мы не можем создавать экземпляр интерфейса:
```java
MathGeom m = new MathGeom();    // ошибка
```
Его можно лишь применять к тому или иному классу. Для этого используется следующий синтаксис:
```java
class <имя класса> [extends <имя базового класса>] [implements <интерфейс1> [, <интерфейс2>, …, <интерфейсN>]] {  
}
```
То есть, для подключения (реализации) интерфейсов следует писать ключевое слово implements и через запятую указывать интерфейсы, применяемые в текущем классе. В нашем случае это будет выглядеть так:
```java
class Rectangle extends Geom implements MathGeom {
    void draw() {
        System.out.println("Рисование прямоугольника");
    }
 
    public double getSquare() {
        return 5*10;
    }
}
 
class Triangle extends Geom implements MathGeom {
    void draw() {
        System.out.println("Рисование треугольника");
    }
 
    public double getSquare() {
        return 0.5*4*10;
    }
}
```
Обратите внимание, после указания интерфейса MathGeom при объявлении класса, внутри него обязательно нужно определить метод getSquare, причем сигнатура этого метода должна полностью совпадать с сигнатурой в интерфейсе MathGeom и стоять модификатор доступа public. Это строго обязательно. То же самое делается в классе Triangle.

Все, вот так мы объявили и применили интерфейс MathGeom к двум классам: Rectangle и Triangle. Причем, сделали это независимо от иерархии наследования классов. И, далее, благодаря этому общему интерфейсу, мы можем в функции main обращаться к методу getSquare единым образом, например, так:
```java
for(int i = 0;i < N; ++i)
    if( g[i] instanceof MathGeom ) {
        double s = ((MathGeom) g[i]).getSquare();
        System.out.println("i: " + i + ", s = " + s);
    }
```
Смотрите, здесь сначала идет проверка: определен ли интерфейс MathGeom в объекте `g[i]`, с помощью оператора [instanceof](instanceof) и если да, то выполняется приведение типов к этому интерфейсу и через него уже вызывается метод getSquare, который в нем определен. Вот пример того, как можно использовать методы в конкретной задаче.

### Интерфейс как тип данных

Давайте еще раз внимательно посмотрим вот на эту строчку:
```java
double s = ((MathGeom) g[i]).getSquare();
```
Здесь происходит приведение типов от Geom к MathGeom. Но это значит, что имя интерфейса можно воспринимать как тип данных? Это действительно так. В частности, если добавить еще один интерфейс GeomInterface:
```java
interface GeomInterface {
    double[] getCoords();
}
```
и применить его ко всем трем классам графических примитивов:
```java
class Line extends Geom implements GeomInterface {
    void draw() {
        System.out.println("Рисование линии");
    }
 
    public double[] getCoords() {
        return new double[] {1, 2, 3, 4};
    }
}
 
class Rectangle extends Geom implements MathGeom, GeomInterface {
    void draw() {
        System.out.println("Рисование прямоугольника");
    }
 
    public double getSquare() {
        return 5*10;
    }
 
    public double[] getCoords() {
        return new double[] {10, 20, 30, 40};
    }
}
 
class Triangle extends Geom implements MathGeom, GeomInterface {
    void draw() {
        System.out.println("Рисование треугольника");
    }
 
    public double getSquare() {
        return 0.5*4*10;
    }
 
    public double[] getCoords() {
        return new double[] {11, 12, 13, 14};
    }
}
```
То в функции main, мы можем создать обобщенные ссылки типа GeomInterface:
```java
final int N = 3;
GeomInterface g[] = new GeomInterface[N];
g[0] = new Line();
g[1] = new Rectangle();
g[2] = new Triangle();
```
и через них обращаться к методу getCoords:
```java
for(int i = 0;i < N; ++i) {
    double coords[] = g[i].getCoords();
    for(int j = 0;j < coords.length; ++j)
        System.out.print(coords[j] + " ");
    System.out.println();
}
```
Разумеется, ссылки `g[0], g[1], g[2]` будут иметь доступ только к методу getCoords, определенному в интерфейсе GeomInterface и ни к чему более. Также этот пример показывает, что класс может применять сразу несколько интерфейсов (в этом случае они записывают через запятую после ключевого слова implements). И тогда в нем следует определять методы из обоих интерфейсов.

### Константы в интерфейсах

Давайте в интерфейсе GeomInterface пропишем две вот такие переменные:
```java
interface GeomInterface {
    int MIN_COORD = 0;
    int MAX_COORD = 1000;
}
```
Эти переменные являются константами. Дело в том, что в Java к этим определениям автоматически добавляются ключевые слова: __public static final__ и любые переменные превращаются в общедоступные статические константы. То есть, в интерфейсах попросту нельзя объявлять переменные – только константы. Далее, мы можем использовать MIN_COORD и MAX_COORD в классах, где применен интерфейс GeomInterface. Например, в классе Line:
```java
class Line extends Geom implements GeomInterface, MathGeom {
    int x1, y1, x2, y2;
 
    void draw() {
        System.out.println("Рисование линии");
    }
 
    private boolean isCheck(int x) {
        return (MIN_COORD <= x && x <= MAX_COORD);
    }
 
    void setCoord(int x1, int y1, int x2, int y2) {
        if(isCheck(x1) && isCheck(y1) && isCheck(x2) && isCheck(y2)) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }
    }
}
```
Смотрите, мы здесь объявили сеттер setCoord и в нем проверяем соответствие переданных координат диапазону `[MIN_COORD; MAX_COORD]` с помощью вспомогательного приватного метода isCheck. Наличие констант как раз и объясняется их объявлением в интерфейсе GeomInterface.

### Статические методы в интерфейсах

Но если в интерфейсе можно объявлять статические константы, то можно ли задавать и статические методы? Да, это стало возможно, начиная с версии JDK 8, и делается очевидным образом:
```java
interface GeomInterface {
    int MIN_COORD = 0;
    int MAX_COORD = 1000;
 
    static void showInterval() {
        System.out.println("[" + MIN_COORD + "; " + MAX_COORD + "]");
    }
}
```
Здесь объявлен статический метод showInterval, который должен иметь реализацию. То есть, объявлять такие методы без реализации уже нельзя. И они не могут быть переопределены в классах.
Статический метод - это метод, располагающийся в строго определенной области памяти на всем протяжении работы программы. Следовательно, к нему можно обратиться и вызвать непосредственно из интерфейса, в котором он определен. Например, так:
```java
GeomInterface.showInterval();
```
Точно также к нему следует обращаться и из экземпляров классов, например:
```java
class Line extends Geom implements GeomInterface, MathGeom {
    int x1, y1, x2, y2;
 
    void draw() {
        GeomInterface.showInterval();
        System.out.println("Рисование линии");
    }
…
}
```
Фактически, мы получаем неизменяемые методы, объявленные внутри интерфейса.

### Вложенные интерфейсы и их расширение

Далее, интерфейсы можно объявлять внутри классов. Делается это очевидным образом, и я здесь приведу лишь отвлеченный пример. Пусть имеется класс InterfaceGroup, в котором определены два интерфейса: Interface_1 и Interface_2:
```java
class InterfaceGroup {
    interface Interface_1 {
        void method_1();
    }
 
    interface Interface_2 {
        void method_2();
    }
}
```
То есть, класс как бы образует группу интерфейсов. Далее, для их применения в классах, используется следующий синтаксис:
```java
class ReleaseInterface implements InterfaceGroup.Interface_1 {
    public void method_1() { }
}
```
Мы здесь указываем сначала имя класса, а затем, через точку имя интерфейса. Но так можно делать, если модификатор доступа позволяет обратиться к интерфейсу извне. Например, если у первого указать модификатор private:
```java
class InterfaceGroup {
    private interface Interface_1 {
        void method_1();
    }
...
}
```
то возникнет ошибка. Такой интерфейс можно использовать только внутри класса. Как? Например, для расширения других публичных интерфейсов. Расширение – это когда один интерфейс наследуется от другого. В частности, мы можем расширить Interface_2, следующим образом:
```java
class InterfaceGroup {
    private interface Interface_1 {
        void method_1();
    }
 
    interface Interface_2 extends Interface_1 {
        void method_2();
    }
}
```
То есть, здесь используется тот же синтаксис, что и при наследовании классов, только применительно к интерфейсам. В результате такой операции, второй интерфейс унаследует все публичные элементы первого. И, затем, указывая его в классе ReleaseInterface, должны определить уже два метода:
```java
class ReleaseInterface implements InterfaceGroup.Interface_2 {
    public void method_1() { }
    public void method_2() { }
}
```

### Приватные методы интерфейса

Но что значит: _наследуются все публичные методы интерфейса_? Разве в интерфейсах методы и константы могут быть не публичными? Да, начиная с версии JDK 9, допускается в интерфейсах объявлять приватные методы. Конечно, они обязательно должны иметь реализацию и используются исключительно внутри интерфейса. Например, мы можем объявить такой приватный метод:
```java
class InterfaceGroup {
    private interface Interface_1 {
        void method_1();
 
        private void privateMethod() {
            System.out.println("privateMethod");
        }
    }
...
}
```
Тогда при расширении второго интерфейса этот метод унаследован не будет.

Приватные методы используются исключительно для внутреннего использования, например, для программирования повторяющихся действий, когда мы используем описание метода с реализацией по умолчанию. Об этом речь пойдет дальше.

### Интерфейсы с абстрактными классами

Давайте теперь зададимся вопросом: а можно ли к [абстрактному классу](AbstractInterface) применять интерфейсы? Оказывается, да, можно и при этом реализация интерфейсного метода getSquare в нем может отсутствовать:
```java
interface MathGeom {
    double getSquare();
}
 
abstract class Geom implements MathGeom {
    int width, color;
    abstract void draw();
}
```
В этом случае метод getSquare обязательно должен быть определен в дочернем классе. Если же этот метод прописать непосредственно в классе Geom:
```java
abstract class Geom implements MathGeom {
    int width, color;
    abstract void draw();
 
    public double getSquare() {
        return 0;
    }
}
```
То дочерние классы могут его не переопределять. Тогда при обращении к getSquare() будет возвращаться значение 0. Благодаря такой гибкости, мы можем в программе реализовывать самую разную логику взаимодействия с интерфейсами.

### Методы с реализацией по умолчанию

Фактически вот этот последний пример позволяет использовать [абстрактный класс](AbstractInterface) для определения метода getSquare с реализацией по умолчанию (то есть, его действие, когда он не переопределяется в дочерних классах). Так приходилось делать до версии JDK 8, чтобы не «заставлять» программистов определять методы интерфейса, если это не требовалось. Теперь (начиная с JDK 8 и выше) в интерфейсах можно определять методы с реализацией по умолчанию и такие методы можно не переопределять в классах. Для их объявления используется следующий синтаксис:
```java
default <тип метода> <имя метода>([аргументы]) {  
      [операторы]  
}
```
Например, определим в интерфейсе MathGeom метод getSquare с реализацией по умолчанию:
```java
interface MathGeom {
    default double getSquare() {
        return 0;
    }
}
```
И применим его ко всем классам графических примитивов:
```java
interface GeomInterface {
    double[] getCoords();
}
 
class Line extends Geom implements GeomInterface, MathGeom {
    void draw() {
        System.out.println("Рисование линии");
    }
 
    public double[] getCoords() {
        return new double[] {1, 2, 3, 4};
    }
}
 
class Rectangle extends Geom implements GeomInterface, MathGeom {
    void draw() {
        System.out.println("Рисование прямоугольника");
    }
 
    public double getSquare() {
        return 5*10;
    }
 
    public double[] getCoords() {
        return new double[] {10, 20, 30, 40};
    }
}
 
class Triangle extends Geom implements GeomInterface, MathGeom {
    void draw() {
        System.out.println("Рисование треугольника");
    }
 
    public double getSquare() {
        return 0.5*4*10;
    }
 
    public double[] getCoords() {
        return new double[] {11, 12, 13, 14};
    }
}
```
Смотрите, в классе Line мы не переопределяли метод getSquare, а в классах Rectangle и Triangle он переопределен. Теперь, создавая экземпляры этих классов в функции main:
```java
final int N = 3;
Geom g[] = new Geom[N];
g[0] = new Line();
g[1] = new Rectangle();
g[2] = new Triangle();
```
мы можем совершенно свободно вызывать у них метод getSquare:
```java
MathGeom m = null;
for(int i = 0;i < N; ++i) {
	m = (MathGeom) g[i];
    System.out.println(m.getSquare());
}

```
Обратите внимание, нам здесь сначала нужно привести ссылку `g[i]` к типу MathGeom и только потом вызвать метод getSquare. В консоли увидим значения:
<p style="background-color: navy; color: yellow">
0.0 <br>
50.0 <br>
20.0</p>

Здесь первый ноль был получен из реализации метода по умолчанию для класса Line. Остальные значения – из переопределенных методов. То есть, теперь, мы можем не прописывать реализацию метода getSquare в классах примитивов, если она нам не нужна. И это добавляет дополнительное удобство при программировании.

Но что будет, если в GeomInterface также определить метод getSquare с реализацией по умолчанию:
```java
interface GeomInterface {
    double[] getCoords();
 
    default double getSquare() {
        return -1;
    }
}
```
Тогда для класса Line, который применяет оба интерфейса, какая реализация будет использована? В действительности, никакая. Виртуальная машина Java в этом случае выдаст ошибку и потребуется явное определение этого метода. И это можно сделать так:
```java
class Line extends Geom implements GeomInterface, MathGeom {
…
    public double getSquare() {
        return GeomInterface.super.getSquare();
    }
}
```
Смотрите, мы здесь из переопределенного метода getSquare обращаемся к объекту GeomInterface через ключевое слово super и, затем, вызываем его метод по умолчанию getSquare. Если теперь запустить программу, то ошибок не будет и в консоли для линии увидим значение -1. А вот если этот метод прописать так:
```java
    public double getSquare() {
        return MathGeom.super.getSquare();
    }
```
то он будет вызван из интерфейса MathGeom и вернет значение 0. Вот так, непосредственно из экземпляра класса можно обращаться к объектам интерфейсов и использовать их элементы. Конечно, это имеет смысл только в условиях неопределенности, например, как в нашем случае. Иначе, достаточно просто записать имя метода или константы и она будет взята из соответствующего интерфейса или базового класса.

