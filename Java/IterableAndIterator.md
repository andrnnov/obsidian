#Java #Iterator #Iterable 
#### [Iterable](Iterable) и [Iterator](Iterator) в Java ####

2023-10-30 11:07

Многие люди чувствуют себя сбитыми с толку интерфейсами Iterator и Iterable в Java, потому что у них очень похожие названия, и иногда они работают вместе, из-за чего люди с трудом различают их. В этой статье мы собираемся разъяснить разницу между ними и посмотреть, как их можно использовать на некоторых примерах.

Короче говоря, интерфейс Iterable принадлежит пакету java.lang, в то время как интерфейс Iterator является частью пакета java.util. Iterable - это простое представление ряда элементов, которые можно перебирать, но оно не предоставляет никакого состояния итерации для получения “текущего элемента”. Iterator, с другой стороны, позволяет вам выполнять итерацию по элементам итерируемых объектов. Вы можете выполнить итерацию по каждому элементу коллекции, используя методы hasNext() и next() этого интерфейса.
#### Интерфейсы Iterable и Iterator ####

Для интерфейса Iterable существует несколько распространенных методов:
- `default void forEach(Consumer<? super T> action)` выполняйте заданную функцию для каждого элемента Iterable до тех пор, пока не будут обработаны все элементы или не возникнет исключение. 
- `default Spliterator<T> spliterator()` создает разделитель поверх элементов 
- `Iterator<T> iterator()` возвращает итератор для элементов типа T.
Любой класс, реализующий этот интерфейс, должен переопределять метод iterator()..

Вот некоторые часто используемые методы интерфейса Iterator:
- `E next()` возвращает следующий элемент с типом E в итерации. 
- `boolean hasNext()` возвращает значение true, если итерация все еще содержит один или несколько элементов. 
- `void remove()` удаляет элемент из базовой коллекции, который является последним элементом, возвращенным из итератора.
Любой класс, реализующий интерфейс Iterator, должен переопределять методы next() и hasNext().
Как вы можете видеть, взаимосвязь между интерфейсом Iterable и Iterator близка, реализация Iterable - это та, которая предоставляет итератор сама по себе.
#### Типичный пример ####

Cам класс в интерфейсе Collection косвенно реализует интерфейс Iterable, поэтому мы можем использовать каждый метод, определенный в интерфейсе Iterable, например, у нас есть список List, подобный этому:
```java
List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
nums.forEach(/* some code */);
nums.iterator();
nums.spliterator();
```
Более конкретно, класс ArrayList реализует интерфейс List, интерфейс List реализует интерфейс Collection, интерфейс Collection расширяет интерфейс Iterable.
Суть здесь в том, что любая коллекция, реализующая интерфейс Iterable, предоставляет вам метод iterator(), который возвращает итератор, и мы можем использовать это для итерации по каждому элементу коллекции:
```java
public static void main(String[] args) {
        List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        Iterator<Integer> iterator = nums.iterator();
        while(iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
       // output: 1 2 3 4 5
}
```
Мы также можем использовать цикл for-each, который внутренне вызывает метод iterator() для объекта:
```java
public static void main(String[] args) {
        List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        for (Integer num : nums) {
            System.out.print(num + " ");
        }
}
```
Метод forEach() также может быть использован для итерации по коллекции, которая также использует for-each внутренне:
```java
public static void main(String[] args) {
        List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        nums.forEach(e -> System.out.print(e + " ")); // 1 2 3 4 5
}
```
#### Дополнительные примеры интерфейсом Iterator ####

Iterable не поддерживает текущее состояние итерации, но Iterator поддерживает. С помощью Iterator мы можем получить текущий элемент, двигаясь вперед, если еще есть какие-то элементы, и при необходимости удалить элемент из базовой коллекции:
```java
public static void main(String[] args) {
        List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        Iterator<Integer> iterator = nums.iterator();
        while(iterator.hasNext()) {
            int i = iterator.next();
            System.out.print(i + " ");
            if (i % 2 == 0) {
                iterator.remove();
            }
        }
        System.out.println();
        for(Integer i: nums) {
            System.out.print(i + " ");
        }
       /* output: 
        1 2 3 4 5 6 7 8 9 10 
        1 3 5 7 9 
       */
}
```
В этом примере мы просто-напросто создаем список с десятью целыми числами от 1 до 10. Затем мы создаем итератор из этой коллекции, он повторяется до тех пор, пока не останется ни одного элемента, мы печатаем каждый элемент на каждой итерации, а затем удаляем четные элементы из базовой коллекции с помощью метода remove().
Обратите внимание, что каждый раз, когда вы вызываете метод next(), он возвращает следующий элемент в итерации, следовательно, вам нужно обратить немного внимания на это:
```java
while (iterator.hasNext()) {
       System.out.println(iterator.next());
       if(iterator.next() % 2 == 0) {
          iterator.remove();
       }
}
/* it will just print 1 3 5 7 9 */
```
#### Итог ####

Давайте подытожим то, что мы узнали:
- Интерфейс Iterable предоставляет вам представление ряда элементов, по которым можно выполнить итерацию, но нам нужен итератор, чтобы получить состояние итерации. 
- У самого Iterable есть метод, возвращающий итератор. 
- Интерфейс Collection расширяет Iterable, поэтому вы можете напрямую использовать методы Iterable в любом подклассе, принадлежащем этому интерфейсу Collection, элементы которого по своей сути являются iterable. 
- Классы, реализующие Iterable, должны переопределять метод iterator(), в то время как он обязан переопределять методы next() и hasNext(), если класс реализует Iterator. 
- Вы не можете изменять элементы с помощью Iterable, но Iterator может выдать вам текущее состояние итерации с помощью методов next() и hasNext() и удалить элемент из базовой коллекции с помощью метода remove().