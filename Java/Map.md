#Java #Collections #Map
#### [Java Map](https://www.jenkov.com/tutorials/java-collections/map.html) ####

2023-10-31 16:40

Интерфейс Java Map, java.util.Map, представляет собой сопоставление между ключом и значением. Более конкретно, Java-карта может хранить пары ключей и значений. Каждый ключ связан с определенным значением. После сохранения на карте вы можете позже найти значение, используя только ключ.

Интерфейс Java Map не является подтипом интерфейса [[Collections#Интерфейс Java Collection|Collection]]. Поэтому он ведет себя немного иначе, чем остальные типы коллекций.
#### Реализации Java Map ####

Поскольку Map - это интерфейс, вам необходимо создать экземпляр конкретной реализации интерфейса Map, чтобы использовать его. Java [Collections](Collections) API содержит следующие реализации карт:
- [java.util.HashMap](HashMap)
- [java.util.Hashtable](Hashtable)
- [java.util.EnumMap](EnumMap)
- java.util.IdentityHashMap
- [java.util.LinkedHashMap](LinkedHashMap)
- java.util.Properties
- [java.util.TreeMap](TreeMap)
- [java.util.WeakHashMap](WeakHashMap)

Наиболее часто используемыми реализациями карт являются [HashMap](HashMap) и [TreeMap](TreeMap). Каждая из этих реализаций Map ведет себя немного по-разному в отношении порядка элементов при итерации карты и времени (big O notation), необходимого для вставки элементов в Map и доступа к ним.

[HashMap](HashMap) отображает ключ и значение. Это не гарантирует какого-либо порядка элементов, хранящихся внутри карты. TreeMap также отображает ключ и значение. Кроме того, это гарантирует порядок, в котором повторяются ключи или значения, то есть порядок сортировки ключей или значений.

Реализация [HashMap](HashMap), как правило, является самой быстрой из двух реализаций Map, поэтому всякий раз, когда вам не нужно сортировать элементы на карте, вы можете просто использовать [HashMap](HashMap). В противном случае используйте [TreeMap](TreeMap).
#### Создание Map ####

Чтобы создать Java Map, вы должны создать экземпляр одного из классов, реализующих интерфейс Java Map. Вот несколько примеров того, как создать экземпляр карты:
```java
Map mapA = new HashMap();

Map mapB = new TreeMap();
```
#### Generic Java Map ####

По умолчанию вы можете поместить любой объект в карту, но начиная с Java 5 Java [Generics](Generics) позволяет ограничить типы объектов, которые вы можете использовать как для ключей, так и для значений на карте. Вот пример:
```java
Map<String, MyObject> map =  new HashMap<String, MyObject>();
```
Эта карта теперь может принимать только строковые объекты в качестве ключей и экземпляры MyObject в качестве значений. Затем вы можете получить доступ к ключам и значениям и выполнять их итерацию без их приведения. Вот как это выглядит:
```java
for(MyObject anObject : map.values()){   //do someting with anObject...
}
for(String key : map.keySet()){
   MyObject value = map.get(key);   //do something to value
}
```
Если вы знаете тип объектов, хранящихся на карте, считается хорошей практикой всегда указывать общий тип при объявлении и создании Java-карты. Универсальный тип помогает вам избежать вставки неправильных объектов и облегчает людям, читающим ваш код, понимание того, какие объекты содержит карта.
#### Вставка элементов в Java Map ####

Чтобы добавить элементы на карту, вы вызываете ее метод put(). Вот несколько примеров:
```java
Map<String, String> map = new HashMap<>();

map.put("key1", "element 1");
map.put("key2", "element 2");
map.put("key3", "element 3");
```
Три вызова put() сопоставляют строковое значение со строковым ключом.
##### Только объекты могут быть вставлены #####

Только объекты Java могут использоваться в качестве ключей и значений в Java Map. В случае, если вы передаете примитивные значения (например, int, double и т.д.) Map в качестве ключа или значения, примитивные значения будут автоупаковыны (autoboxing)  перед передачей в качестве параметров. Вот пример автоматической упаковки примитивных параметров, передаваемых методу put():
```java
map.put("key", 123);
```
Значение, передаваемое методу put() в приведенном выше примере, является примитивным значением int. Однако Java автоматически помещает его в экземпляр Integer, поскольку метод put() требует экземпляр Object как в качестве ключа, так и в качестве значения. Автоупаковка также произошла бы, если бы вы передали примитив в качестве ключа методу put().

Данный ключ может встречаться в Java-карте только один раз. Это означает, что в карте одновременно может существовать только одна пара ключ + значение для каждого ключа. Другими словами, для ключа "key1" в одном экземпляре карты может быть сохранено только одно значение. Конечно, вы можете хранить значения для одного и того же ключа в разных экземплярах карты. 

Если вы вызываете put() более одного раза с одним и тем же ключом, последнее значение, переданное put() для этого ключа, перезапишет то, что уже сохранено в карте для этого ключа. Другими словами, последнее значение заменяет существующее значение для данного ключа.
##### Null Keys #####

Довольно удивительно, что вы можете использовать значение null в качестве ключа в Java Map. Вот пример использования нулевого ключа в Java Map:
```java
Map map = new HashMap();

map.put(null, "value for null key");
```
Чтобы получить значение, сохраненное ключом null, вы вызываете метод get() с null в качестве значения параметра. Вот пример получения значения для нулевого ключа Java Map:
```java
Map<String, String> map = new HashMap<>();

String value = map.get(null);
```
##### Null Values #####

Значение пары ключ + значение, хранящейся в карте, может быть равно null - так что это допустимо:
```java
map.put("D", null);
```
Просто имейте в виду, что вы получите значение null, когда позже вызовете get() с этим ключом - так что это вернет значение null:
```java
Object value = map.get("D");
```
Переменная value будет иметь значение null после выполнения этого кода, если ранее для этого ключа было вставлено значение null (как в предыдущем примере).
#### Вставка всех Элементов с Другой Карты ####

Интерфейс Java Map имеет метод, называемый putAll(), который может скопировать все пары ключ + значение (записи) из другого экземпляра карты в себя. В теории множеств это также называется объединением двух экземпляров Map. Вот пример копирования всех записей из одной Java-карты в другую с помощью putAll():
```java
Map<String, String> mapA = new HashMap<>();
mapA.put("key1", "value1");
mapA.put("key2", "value2");

Map<String, String> mapB = new HashMap<>();
mapB.putAll(mapA);
```
После запуска этого кода карта, на которую ссылается переменная mapB, будет содержать обе записи ключ + значение, вставленные в mapA в начале примера кода. Копирование записей выполняется только в одну сторону. Вызов mapB.putAll(mapA) приведет только к копированию записей из mapA в mapB, а не из mapB в mapA. Чтобы скопировать записи другим способом, вам нужно будет выполнить код mapA.putAll(mapB).
#### Получение элементов с карты ####

Чтобы получить определенный элемент, хранящийся в Java Map, вы вызываете его метод get(), передавая ключ для этого элемента в качестве параметра. Вот пример получения значения, сохраненного в Java Map:
```java
Map map = new HashMap();

map.put("key1", "value 1");

String element1 = (String) map.get("key1");
```
Обратите внимание, что метод get() возвращает объект Java, поэтому мы должны преобразовать его в строку (потому что мы знаем, что значение является строкой).
#### Get or Default Value ####

Интерфейс Java Map имеет метод getOrDefault(), который может возвращать значение по умолчанию, указанное вами - в случае, если значение по данному ключу не сохранено на карте. Вот пример получения значения из Java Map с резервным значением по умолчанию:
```java
Map<String, String> map = new HashMap<>();

map.put("A", "1");
map.put("B", "2");
map.put("C", "3");

String value = map.getOrDefault("E", "default value");
```
В этом примере создается карта и сохраняются в ней три значения, используя ключи A, B и C. Затем в примере вызывается метод Map getOrDefault(), передающий строку E в качестве ключа вместе со значением по умолчанию - String default value. Поскольку карта не содержит никакого объекта, сохраненного ключом E, будет возвращено заданное значение по умолчанию, которое является строковым значением по умолчанию, передаваемым в качестве последнего параметра методу getOrDefault().
#### Проверка, содержит ли карта ключ ####

Вы можете проверить, содержит ли Java Map определенный ключ, используя метод containsKey(). Вот как это выглядит:
```java
boolean hasKey = map.containsKey("123");
```
После выполнения этого кода переменная hasKey будет иметь значение true, если ранее была вставлена пара ключ + значение со строковым ключом 123, и false, если такая пара ключ + значение не была вставлена.
#### Проверка, содержит ли карта значение ####

В интерфейсе Java Map также есть метод, который позволяет вам проверить, содержит ли карта определенное значение. Метод называется containsValue(). Вот как выглядит вызов containsValue():
```java
boolean hasValue = map.containsValue("value 1");
```
После выполнения этого кода переменная HasValue будет содержать значение true, если пара ключ + значение была вставлена ранее со строковым значением "value 1", и false, если нет.
#### Итерация ключей в Java Map ####

Существует несколько способов перебора ключей, хранящихся в Java Map. Наиболее часто используемыми методами перебора ключей являются:
- Через итератор ключа 
- Через цикл for-each 
- Через поток
#### Использование итератора ключа ####

 Вы можете перебирать все ключи Java Map с помощью ее метода keySet(). Вот как выглядит итерация ключей Java Map:
```java
 Iterator iterator = map.keySet().iterator();

  while(iterator.hasNext(){
	  Object key   = iterator.next();
	  Object value = map.get(key);
  }
```
Как вы можете видеть, итератор ключей возвращает каждый ключ, хранящийся в Java Map, один за другим (по одному для каждого вызова next()). Как только у вас есть ключ, вы можете получить элемент, сохраненный для этого ключа, используя метод Map get(). 

В приведенном выше примере метод [Iterator](Iterator) next() возвращает объект, как и метод get(). С универсальными типами, указанными для карты, эти методы вернули бы тип объектов key и value соответственно. Вот как это выглядело бы:
```java
Map<String, String> map = new HashMap<>();

Iterator<String> iterator = map.keySet().iterator();

while(iterator.hasNext(){
  String key   = iterator.next();
  String value = map.get(key);
}
```
Обратите внимание, что общий тип теперь также указан для итератора, полученного из map.keySet().iterator().
#### Использование ключа для цикла ForEach ####

Начиная с Java 5, вы также можете использовать цикл for-each для перебора ключей, хранящихся в Java Map. Вот как это выглядит:
```java
for(Object key : map.keySet()) {
    Object value = map.get(key);
}
```
Эффект приведенного выше кода очень похож на код, показанный в предыдущем разделе. 

Если вы указали общий тип для Java Map, то вы можете использовать этот тип внутри цикла for-each. Вот как это выглядит:
```java
Map<String, String> map = new HashMap<>();

for(String key : map.keySet()) {
    String value = map.get(key);
}
```
##### Использование Key Stream #####

Начиная с Java 8, вы можете использовать Java Stream для перебора ключей Java Map. Потоковый интерфейс является частью Java [Stream API](StreamAPI), который был добавлен в Java 8. Сначала вы получаете набор ключей с карты, и из этого вы можете получить поток. Вот пример итерации ключей Java Map через поток:
```java
Map<String, String> map = new HashMap<>();

map.put("one", "first");
map.put("two", "second");
map.put("three", "third");

Stream<String> stream = map.keySet().stream();
stream.forEach((value) -> {
    System.out.println(value);
});
```
#### Итерация по значению в Java Map ####

Также возможно просто выполнить итерацию значений, хранящихся в Java Map. Вы получаете коллекцию значений, хранящихся на карте, с помощью метода values(). Вы можете перебирать значения в коллекции следующими способами:
- Использование итератора
- Использование цикла for-each
- Использование потока 
##### Использование итератора по значению #####

Первый способ перебрать все значения, хранящиеся в Java Map, - это получить экземпляр value [Iterator](Iterator) из набора значений и выполнить его итерацию. Вот как выполняется итерация значений, хранящихся в Java Map, с помощью итератора значений:
```java
Map<String, String> map = new HashMap<>();

Iterator<String> iterator = map.values().iterator();

while(iterator.hasNext()) {
    String nextValue  iterator.next();
}
```
Поскольку множество Set неупорядоченно, у вас нет никаких гарантий относительно порядка, в котором повторяются значения в множестве значений. Однако, если вы используете [TreeSet](TreeSet), вы все равно можете контролировать этот порядок.
##### Использование значения в цикле ForEach #####

Второй метод итерации значений, хранящихся в Java Map, осуществляется с помощью цикла Java for-each. Вот как итерация значений Java Map с использованием цикла for-each выглядит в коде:
```java
Map<String, String> map = new HashMap<>();

for(String value : map.values()){
    System.out.println(value);
}
```
В этом примере будут распечатаны все значения, хранящиеся в переменной mapA Map.
##### Использование потока #####

Третий способ перебора значений, хранящихся в Java Map, - это использование потока значений, используя Java [Stream API](StreamAPI). Сначала вы получаете набор значений из карты, а из набора значений вы можете получить поток. Вот пример итерации значений Java Map через поток создания значений:
```java
Map<String, String> map = new HashMap<>();

map.put("one", "first");
map.put("two", "second");
map.put("three", "third");

Stream<String> stream = map.values().stream();
stream.forEach((value) -> {
    System.out.println(value);
});
```
#### Итерация записей в Java Map ####

Также возможно выполнить итерацию всех записей Java-карты. Под записями я подразумеваю пары ключ + значение. Запись содержит как ключ, так и значение для этой записи. Ранее мы выполняли итерацию только либо ключей, либо значений, но, повторяя записи, мы выполняем итерацию обоих одновременно. Как и в случае с ключами и значениями, существует два способа перебора записей карты:
- Использование [итератора](Iterator) по значению
- Используя цикл for-each
##### Использование итератора по значению #####

Первый способ перебора записей карты Java - это использование итератора записей, полученного из набора записей. Вот пример итерации записей Java Map:
```java
Set<Map.Entry<String, String>> entries = map.entrySet();

Iterator<Map.Entry<String, String>> iterator =
    entries.iterator();

while(iterator.hasNext()) {
    Map.Entry<String, String> entry = iterator.next();
    String key   = entry.getKey();
    String value = entry.getValue();
}
```
Обратите внимание, как ключ и значение могут быть получены из каждого экземпляра Map.Entry.
##### Используя цикл for-each #####

Второй способ перебора записей Java-карты заключается в использовании цикла for-each. Вот пример итерации записей Java-карты с использованием цикла for-each:
```java
for(Map.Entry<String, String> entry : map.entrySet()){
    String key = entry.getKey();
    String value = entry.getValue();
}
```
Обратите внимание, что этот пример тоже можно сделать немного красивее, используя [generic](Generics) Map.
#### Удаление записей с Java Map ####

Вы удаляете записи, вызывая метод remove(Object key). Таким образом, вы удаляете пару (ключ, значение), соответствующую ключу. Вот пример удаления записи для данного ключа в Java Map :
```java
map.remove("key1");
```
После выполнения этой инструкции карта, на которую ссылается mapA, больше не будет содержать запись (пара ключ + значение) для ключа key1.
#### Удалить все записи ####

Вы можете удалить все записи в Java Map, используя метод clear(). Вот как это выглядит:
```java
map.clear();
```
#### Замена записи в Java Map ####

Можно заменить элемент в Java Map, используя метод replace(). Метод replace() вставит новое значение только в том случае, если ключу уже сопоставлено существующее значение. Если никакое существующее значение не сопоставлено с данным ключом, значение не вставляется. Это отличается от того, как работает функция put(), которая всегда вставляет значение, несмотря ни на что. 

Вот пример замены одного значения другим с использованием метода Java Map replace(): 
```java
Map map = new HashMap<>();

map.replace("key", "val2"); //no "key" entry, no replace

map.put("key", "val1");     //now contains "key" entry

map.replace("key", "val2"); //now "key" entry replaced
```
После выполнения этого кода экземпляр карты будет содержать строковое значение newer value для ключа String key .
#### Считывание количества записей Map ####

Вы можете прочитать количество записей в Java-карте, используя метод size(). Количество записей в Java-карте также называется размером карты - отсюда и название метода size() . Вот пример считывания количества записей на карте с помощью метода size():
```java
int entryCount = map.size();
```
#### Проверка того, пуста ли Java Map ####

В интерфейсе Java Map есть специальный метод для проверки того, является ли карта пустой. Этот метод называется isEmpty() и возвращает либо true, либо false. Метод isEmpty() вернет значение false, если экземпляр карты содержит 1 или более записей. Если карта содержит 0 записей, isEmpty() вернет значение true.
#### Функциональные операции в Java Map ####

В интерфейс Java Map было добавлено несколько функциональных операций из Java 8. Эти функциональные операции позволяют взаимодействовать с картой в более функциональном стиле. Например, вы передаете лямбда-выражение Java в качестве параметра этим методам функционального стиля.

Функциональными методами являются:
- compute()
- computeIfAbsent()
- computeIfPresent()
- merge()
#####  compute() #####

Метод Map compute() принимает ключевой объект и лямбда-выражение в качестве параметров. [Лямбда-выражение](Lambda) должно реализовывать java.util.function. Двухфункциональный [интерфейс](Interface). Вот пример вызова метода Java Map compute():
```java
map.compute("123", (key, value) ->   
    value == null ? null :   
        value.toString().toUpperCase());
```
Метод compute() вызовет лямбда-выражение внутренне, передавая объект key и любое значение, сохраненное в карте для этого ключевого объекта, в качестве параметров лямбда-выражения. Любое значение, возвращаемое лямбда-выражением, сохраняется вместо текущего сохраненного значения для этого ключа. Если лямбда-выражение возвращает значение null, запись удаляется. В карте не будет сохранено сопоставление key -> null. В приведенном выше примере вы можете видеть, что лямбда-выражение проверяет, является ли значение, сопоставленное данному ключу, нулевым или нет, перед вызовом toString().toUpperCase() для него. Если лямбда-выражение генерирует исключение, запись также удаляется.
##### computeIfAbsent() #####

Метод Map computeIfAbsent() работает аналогично методу compute(), но лямбда-выражение вызывается только в том случае, если для данного ключа еще не существует записи. Значение, возвращаемое лямбда-выражением, вставляется в карту. Если возвращается значение null, запись не вставляется. Если лямбда-выражение генерирует исключение, запись также не вставляется. Вот пример вызова метода Map computeIfAbsent():
```java
map.computeIfAbsent("123", (key) -> "abc");
```
Этот пример на самом деле просто возвращает постоянное значение - строку 123 . Однако [лямбда-выражение](Lambda) могло бы вычислить значение любым необходимым ему способом - например, извлечь значение из другого объекта или объединить его с другими значениями и т.д.
#####  computeIfPresent() #####

Метод Map computeIfPresent() работает противоположно методу computeIfAbsent(). Он вызывает [лямбда-выражение](Lambda), переданное ему в качестве параметра, только в том случае, если запись для этого ключа уже существует в карте. Вот пример вызова метода computeIfPresent():
```java
map.computeIfPresent("123", (key, value) ->   
    value == null ? null :   
        value.toString().toUpperCase());
```
Значение, возвращаемое лямбда-выражением, будет вставлено в экземпляр карты. Если лямбда-выражение возвращает значение null, запись для данного ключа удаляется. Если лямбда-выражение генерирует исключение, исключение запускается повторно, и текущая запись для данного ключа остается неизменной.
##### merge() #####

Метод Map merge() принимает ключ, значение и [лямбда-выражение](Lambda), реализующее интерфейс BiFunction, в качестве параметров. Если в карте нет записи для ключа или если значение для ключа равно null, значение, переданное в качестве параметра методу merge(), вставляется для данного ключа. Однако, если существующее значение уже сопоставлено данному ключу, вместо этого вызывается лямбда-выражение, переданное в качестве параметра. Таким образом, лямбда-выражение получает возможность объединить существующее значение с новым значением. Значение, возвращаемое лямбда-выражением, затем вставляется в карту для данного ключа. Если лямбда-выражение возвращает значение null, запись для данного ключа удаляется. Вот пример вызова метода Map merge():
```java
map.merge("123", "XYZ",   
    (oldValue, newValue) -> newValue + "-abc");
```
В этом примере значение XYZ будет вставлено в карту, если ключу не сопоставлено никакое значение (123) или если ключу сопоставлено значение null. Если ненулевое значение уже сопоставлено ключу, вызывается лямбда-выражение. Лямбда-выражение возвращает новое значение (XYZ) + значение -abc, что означает XYZ-abc. Если лямбда-выражение генерирует исключение, оно генерируется повторно, и текущее отображение для данного ключа сохраняется неизменным.
