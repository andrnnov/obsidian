#Java 
### Оператор :: в Java 8 ###

2023-12-13 11:57

Оператор :: в Java 8 представляет собой удобный способ ссылаться на методы или конструкторы. Это позволяет передать ссылку на метод как аргумент функции или использовать его в лямбда-выражениях.

Оператор :: представляет собой двоеточие, которое разделяет имя класса или экземпляра и имя метода или конструктора. Например, MyUtils::printString, где MyUtils – имя класса, а printString – имя метода.

Оператор :: в Java 8 облегчает использование функциональных интерфейсов, таких как Predicate, Consumer или Function, которые требуют передачи метода в качестве аргумента. Он позволяет передать ссылку на метод вместо написания [лямбда-выражения](Lambda) таким же функционалом. Это упрощает код и делает его более читаемым.

Пример использования оператора :: можно увидеть при работе с коллекциями. Допустим, у нас есть список строк и мы хотим отфильтровать только те строки, которые начинаются с определенного символа. Мы можем использовать оператор :: с методом startsWith класса [String](String):
```java
List<String> strings = Arrays.asList("Apple", "Banana", "Avocado", "Grapes");
List<String> filteredStrings = strings.stream()
                                      .filter(String::startsWith("A"))
                                      .collect(Collectors.toList());
```
Таким образом, оператор :: позволяет нам передать нужный метод в метод filter и применить его к каждому элементу списка.
#### Методы ссылки ####

Методы ссылки в Java 8 позволяют передавать ссылку на [статический метод](Static), метод экземпляра или конструктор вместо написания [лямбда-выражения](Lambda) с таким же функционалом.
##### Ссылка на статический метод #####

Одним из типов методов ссылки является ссылка на статический метод. Это позволяет использовать уже существующий статический метод в качестве аргумента функции или [лямбда-выражения](Lambda). Например, у нас есть класс MathHelper с методом square, который возвращает квадрат числа. Мы можем использовать его вместо [лямбда-выражения](Lambda):
```java
interface SquareFunction {
    int square(int number);
}

public class MathHelper {
    public static int square(int number) {
        return number * number;
    }
}

public class Main {
    public static void main(String[] args) {
        SquareFunction squareFunction = MathHelper::square;
        int result = squareFunction.square(5); // result = 25
    }
}
```
##### Ссылка на метод экземпляра #####

Также возможно использовать метод экземпляра в качестве ссылки. Для этого мы должны иметь экземпляр класса и передать ссылку на его метод. Например, у нас есть класс Person с методом getName, который возвращает имя. Мы можем использовать его вместо [лямбда-выражения](Lambda):
```java
interface NameFunction {
    String getName(Person person);
}

public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person("John");
        NameFunction nameFunction = Person::getName;
        String name = nameFunction.getName(person); // name = "John"
    }
}
```
##### Ссылка на конструктор #####

Метод ссылки также может быть использован для ссылки на конструктор. Это позволяет создавать новый объект, используя его конструктор, вместо написания [лямбда-выражения](Lambda). Например, у нас есть класс Car с конструктором, принимающим модель и цвет. Мы можем использовать его для создания новых объектов:
```java
interface CarFactory {
    Car createCar(String model, String color);
}

public class Car {
    private String model;
    private String color;

    public Car(String model, String color) {
        this.model = model;
        this.color = color;
    }
}

public class Main {
    public static void main(String[] args) {
        CarFactory carFactory = Car::new;
        Car car = carFactory.createCar("Toyota", "Red");
    }
}
```
Методы ссылки предоставляют удобный способ использования уже существующих методов или конструкторов, делая код более читаемым и понятным. В следующих разделах мы рассмотрим применение оператора :: в различных ситуациях.
#### Применение оператора :: в различных ситуациях ####

Оператор :: в Java 8 может быть применен в различных ситуациях, от работы с коллекциями до использования функциональных интерфейсов и многопоточного программирования.
##### Работа с коллекциями #####

Оператор :: может быть использован для более удобной обработки коллекций. Например, мы можем применить его при фильтрации списка объектов или при преобразовании элементов. Рассмотрим пример:
```java
List<String> strings = Arrays.asList("Apple", "Banana", "Avocado", "Grapes");
List<String> filteredStrings = strings.stream()
                                      .filter(String::startsWith("A"))
                                      .collect(Collectors.toList());
```
В данном примере мы использовали метод startsWith класса String с помощью оператора :: для фильтрации строк, которые начинаются с буквы “A”. Полученный результат – список строк, содержащих только элементы, удовлетворяющие условию фильтрации.
##### Функциональные интерфейсы и методы ссылки #####

Одной из основных областей применения оператора:: является использование [функциональных интерфейсов](Functional-Interface) и связанных с ними методов ссылки. Например, функциональный интерфейс  [[Functional-Interface#Consumer|Consumer]] принимает один аргумент и ничего не возвращает. Мы можем использовать методы ссылки для передачи нужного метода в качестве аргумента. Пример:
```java
Consumer<String> printString = System.out::println;
```
Данный пример создает экземпляр [[Functional-Interface#Consumer|Consumer]], который будет выводить переданную строку на консоль. Метод ссылки System.out::println указывает на метод println у объекта System.out.
##### Применение в многопоточном программировании #####

Оператор :: может быть применен для упрощения разработки при работе с многопоточностью. Например, при использовании параллельных потоков, оператор :: может быть использован для указания методов, которые будут применены к каждому элементу потока. Пример:
```java
List<String> strings = Arrays.asList("Apple", "Banana", "Avocado", "Grapes");
strings.parallelStream()
       .forEach(System.out::println);
```
В данном примере каждая строка будет выведена на консоль в параллельном потоке.

