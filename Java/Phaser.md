#Java #Phaser
### [Объект синхронизации Phaser](https://java-online.ru/concurrent-synchronizers.xhtml) ###

Phaser (фазировщик), как и [CyclicBarrier](CyclicBarrier), является реализацией объекта синхронизации типа «Барьер» (CyclicBarrier). В отличии от [CyclicBarrier](CyclicBarrier), _Phaser_ предоставляет больше гибкости. Чтобы лучше понять Phaser, можно привести два наглядно демонстрирующих его использование примера.

_В качестве **первого примера** можно рассмотреть несколько потоков исполнения, реализующих процесс обработки заказов из трех стадий. На первой стадии отдельные потоки исполнения проверяют сведения о клиенте, наличие товара на складе и их стоимость. На второй стадии вычисляется стоимость заказа и стоимость доставки. На заключительной стадии подтверждается оплата и определяется ориентировочное время доставки. Во **втором примере** несколько потоков реализуют перевозку пассажиров городским транспортом. Пассажиры ожидают транспорт на разных остановках. Транспорт, останавливаясь на остановках, одних пассажиров «сажает», других «высаживает»._

В этих примерах общим является то, что один объект синхронизации _Phaser_, исполняющий роль заказа и транспорта, играет главную роль, а другие потоки вступают в работу при определенном состоянии _Phaser_. Таким образом, класс Phaser позволяет определить объект синхронизации, ожидающий завершения определенной фазы. После этого он переходит к следующей фазе и снова ожидает ее завершения.

Важные особенности **Phaser** :
1. Phaser может иметь несколько фаз (барьеров). Если количество фаз равно 1, то плавно переходим к [CyclicBarrier](CyclicBarrier) (осталось только все исполнительные потоки остановить у барьера).
2. Каждая фаза (цикл синхронизации) имеет свой номер.
3. Количество участников-потоков для каждой фазы жестко не задано и может меняться. Исполнительный поток может регистрироваться в качестве участника и отменять свое участие;
4. Исполнительный поток не обязан ожидать, пока все остальные участники соберутся у барьера. Достаточно только сообщить о своем прибытии.

Для создания объекта Phaser используется один из конструкторов :
```java
Phaser();
Phaser(int parties);
Phaser(Phaser parent);
Phaser(Phaser parent, int parties);
```
Параметр _parties_ определяет количество участников, которые должны пройти все фазы. Первый конструктор создает объект Phaser без каких-либо участников. Второй конструктор регистрирует передаваемое в конструктор количество участников. Третий и четвертый конструкторы дополнительно устанавливают родительский объект Phaser.

При создании экземпляр класса Phaser находится в нулевой фазе. В очередном состоянии (фазе) синхронизатор находится в ожидании до тех пор, пока все зарегистрированные потоки не завершат данную фазу. Потоки извещают об этом, вызывая один из методов arrive() или arriveAndAwaitAdvance().

Основные методы:  
- **int register()** — регистрирует нового участника, который выполняет фазы. Возвращает номер текущей фазы;
- **int getPhase()** — возвращает номер текущей фазы;
- **int arriveAndAwaitAdvance()** — указывает что поток завершил выполнение фазы. Поток приостанавливается до момента, пока все остальные стороны не закончат выполнять данную фазу. Точный аналог `CyclicBarrier.await()`. Возвращает номер текущей фазы;
- **int arrive()** — сообщает, что сторона завершила фазу, и возвращает номер фазы. При вызове данного метода поток не приостанавливается, а продолжает выполняться;
- **int arriveAndDeregister()** — сообщает о завершении всех фаз стороной и снимает ее с регистрации. Возвращает номер текущей фазы;
- **int awaitAdvance(int phase)** — если phase равно номеру текущей фазы, приостанавливает вызвавший его поток до её окончания. В противном случае сразу возвращает аргумент.

##### Пример использования Phaser #####

В примере PhaserExample создается несколько потоков, играющих роль пассажиров. Phaser играет роль метро, которое должно проследовать вдоль нескольких станций. Каждая станция (фаза) имеет свой номер. Класс Passenger играет роль пассажира, который на одной из станции должен зайти в вагон, а на другой выйти. Количество пассажиров, а также их места посадки и высадки, формируются случайным образом.

##### Листинг класса Passenger #####

Конструктор класса Passenger получает значение идентификатора, номера станций посадки и назначения (высадки). При создании объекта в консоль выводится информация о пассажире (метод toString).

Как только Phaser переходит в определенную фазу, номер которой соответствует станции посадки пассажира, то поток данного Passenger стартует (run) и выводит в консоль сообщение, что пассажир вошел в вагон, т.е. находится в ожидании следующей станции/фазы (arriveAndAwaitAdvance). Если следующая станция/фаза не будет соответствовать станции назначения, то Passenger продолжит свой путь. Как только Phaser перейдет в фазу, номер которой соответствует номеру станции назначания пассажира, то цикл контроля завершится и поток продолжит работу. С задержкой в 500 ms он сообщит, что покинул вагон и отменит регистрацию в Phaser (arriveAndDeregister).

Таким образом, поток/пассажир дожидается свой фазы/станции в цикле, выделенной в коде пунктирными комментариями. Вызов метода _arriveAndAwaitAdvance_ возвращает значение следующего номера фазы, т.е. участник будет вызван при переходе Phaser в новое состояние. Если в этом состоянии значение фазы (getPhase) будет соответствовать номеру destination, то цикл прервется, в противном случае, ожидание следующей фазы и повторное выполнение проверки условия while.
```java
private static String WAIT  = " ждёт на станции ";
private static String ENTER = " вошел в вагон"   ;
private static String EXIT  = " вышел из вагона ";
private static String SPACE = "    ";

public static class Passenger implements Runnable {
    int id;
    int departure;
    int destination;

    public Passenger(int id, int departure, int destination) {
        this.id          = id;
        this.departure   = departure;
        this.destination = destination;
        System.out.println(this + WAIT + departure);
    }

    @Override
    public void run()  {
        try {
            System.out.println(SPACE + this + ENTER);
            //-----------------------------------------------
            // Заявляем об участии и ждем станции назначения
            while (PHASER.getPhase() < destination)
                PHASER.arriveAndAwaitAdvance();
            //----------------------------------------------
            Thread.sleep(500);
            System.out.println(SPACE + this + EXIT);
            // Отмена регистрации
            PHASER.arriveAndDeregister();
        } catch (InterruptedException e) {}
    }

    @Override
    public String toString() {
        return "Пассажир " + id + 
               " {" + departure + " -> " + destination + '}';
    }
}
```
>**Примечание:** Passenger является внутренним классом примера/класса PhaserExample, и для описания вынесен из общего кода, чтобы не загромождать листинг.

##### Листинг примера PhaserExample #####

В примере сначала создается объект синхронизации PHASER. После этого формируется массив пассажиров. При создании объекта Passenger случайным образом определяются станция посадки и станция назначения. После того как массив пассажиров подготовлен, PHASER в цикле начинает менять свое состояние. На каждом шаге выполняется проверка «станции посадки пассажира». Если она соответствует значению фазы, то данный пассажир входит в вагон метро, т.е. регистрируется в PHASER и поток стартует. Таким образом, регистрация участников (исполнительных потоков) выполняется при нахождении PHASER в определенном состоянии/фазе. Пассажир покинет вагон при достижении метро станции назначения, т.е. при нахождении PHASER в соответствующей фазе. Но это произойдет уже в коде класса Passenger, рассмотренного выше.
```java
import java.util.ArrayList;
import java.util.concurrent.Phaser;

public class PhaserExample {
    private static Phaser PHASER;

    private static String OPEN  = "     открытие дверей ";
    private static String CLOSE = "     закрытие дверей ";

    public static void main(String[] args) throws InterruptedException {
        // Регистрация объекта синхронизации
        PHASER = new Phaser(1);
        ArrayList<Passenger> passengers;
        passengers = new ArrayList<>();
        // Формирование массива пассажиров
        for (int i = 1; i < 5; i++) {
            if ((int) (Math.random() * 2) > 0)
                // Этот пассажир проезжает одну станцию
                passengers.add(new Passenger(10 + i, i, i + 1));
            if ((int) (Math.random() * 2) > 0) {
                // Этот пассажир едет до конечной
                Passenger p = new Passenger(20 + i, i, 5);
               	passengers.add(p);
            }
        }

        // Фазы 0 и 6 - конечные станции // Фазы 1...5 - промежуточные станции
        for (int i = 0; i < 7; i++) {
            switch (i) {
                case 0:
                    System.out.println("Метро вышло из тупика");
                    // Нулевая фаза, участников нет
                    PHASER.arrive();
                    break;
                case 6:
                    // Завершаем синхронизацию
                    System.out.println("Метро ушло в тупик");
                    PHASER.arriveAndDeregister();
                    break;
                default:
                    int currentStation = PHASER.getPhase();
                    System.out.println("Станция " + currentStation);
                    // Проверка наличия пассажиров
                    // на станции
                    for (Passenger pass : passengers)
                        if (pass.departure==currentStation){
                            // Регистрация участника
                            PHASER.register();
                            new Thread (pass).start();
                        }
                    System.out.println(OPEN);
                    // Phaser ожидает завершения фазы // всеми участниками
                    PHASER.arriveAndAwaitAdvance();
                    System.out.println(CLOSE);
            }
        }
    }
```
**Результаты выполнения программы**
<p style="background-color: navy; color: yelloe">
Пассажир 11 {1 -> 2} ждёт на станции 1<br>
Пассажир 21 {1 -> 5} ждёт на станции 1<br>
Пассажир 12 {2 -> 3} ждёт на станции 2<br>
Пассажир 23 {3 -> 5} ждёт на станции 3<br>
Пассажир 14 {4 -> 5} ждёт на станции 4<br>
Метро вышло из тупика<br>
Станция 1<br>
    ... открытие дверей ...<br>
    Пассажир 11 {1 -> 2} вошел в вагон<br>
    Пассажир 21 {1 -> 5} вошел в вагон<br>
    ... закрытие дверей ...<br>
Станция 2<br>
    ... открытие дверей ...<br>
    Пассажир 12 {2 -> 3} вошел в вагон<br>
    Пассажир 11 {1 -> 2} вышел из вагона <br>
    ... закрытие дверей ...<br>
Станция 3<br>
    ... открытие дверей ...<br>
    Пассажир 23 {3 -> 5} вошел в вагон<br>
    Пассажир 12 {2 -> 3} вышел из вагона <br>
    ... закрытие дверей ...<br>
Станция 4<br>
    ... открытие дверей ...<br>
    Пассажир 14 {4 -> 5} вошел в вагон<br>
    ... закрытие дверей ...<br>
Станция 5<br>
    ... открытие дверей ...<br>
    Пассажир 21 {1 -> 5} вышел из вагона <br>
    Пассажир 23 {3 -> 5} вышел из вагона <br>
    Пассажир 14 {4 -> 5} вышел из вагона <br>
    ... закрытие дверей ...<br>
Метро ушло в тупик</p>
