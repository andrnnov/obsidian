#Java #Record

## [Что такое Записи (Records) в Java и как они работают](https://javarush.com/groups/posts/4126-kofe-breyk-230-chto-takoe-zapisi-records-v-java-i-kak-oni-rabotajut)

2024-07-25 10:11

Если вы хотите передавать неизменяемые данные между разными уровнями вашего приложения, то использование **_Record_** может стать хорошим выбором. По умолчанию записи (Records) в Java являются неизменяемыми (immutable), а это означает, что мы не можем изменить их свойства после их создания. В результате это помогает нам избежать ошибок и повышает надежность кода. Проще говоря, используя **_Record_** в Java, мы можем автоматически генерировать классы.

### Где можно использовать Record в Java?

Как правило, мы можем использовать записи в любой ситуации, когда нужно объявить простые контейнеры данных с неизменяемыми свойствами и автоматически сгенерированными методами. Например, ниже приведены несколько вариантов использования, в которых записи могут быть полезны:

- **Объекты передачи данных (Data transfer objects, DTO):** мы можем использовать **_Record_** для объявления простых объектов передачи данных, которые содержат данные. Это полезно при передаче данных между разными уровнями приложения, например, между уровнем службы и уровнем базы данных.

- **Объекты конфигурации:** **_Record_** можно использовать для объявления объектов конфигурации, которые содержат набор свойств конфигурации для приложения или модуля. Эти объекты обычно имеют неизменяемые свойства, что делает их потокобезопасными и простыми в использовании.

- **Объекты-значения.** **_Record_** можно использовать для объявления объектов-значений, которые содержат набор значений, представляющих определенную концепцию или модель предметной области.

- **API Responses (ответы API):** при создании REST API данные обычно возвращаются в форме JSON или XML. В таких случаях может потребоваться определить простую структуру данных, представляющую ответ API. Записи идеально подходят для этого, потому что они позволяют определить легкую и неизменяемую структуру данных, которую можно легко сериализовать в JSON или XML.

- **Тестовые данные.** При написании модульных тестов часто необходимо создавать тестовые данные, представляющие определенный сценарий. В таких случаях может потребоваться определить простую структуру данных, представляющую тестовые данные. Records могут быть идеальными для этого, потому что они позволяют нам определить легкую и неизменяемую структуру данных с минимальным шаблонным кодом.

- **Tuple-подобные объекты:** **_Record_** могут использоваться для объявления Tuple-подобных объектов, которые содержат фиксированное количество связанных значений. Это может быть полезно при возврате нескольких значений из метода или при работе с коллекциями связанных значений.

### [Пример без применения записей (Record)](https://www.tune-it.ru/web/romo/blog/-/blogs/java-records)

Одной из наибольших претензий к Java является то, что для того, чтобы класс мог стать полезным, необходимо написать большое количество избыточного кода. Очень часто вам необходимо дописывать следующее:  
- toString()
- hashCode() и equals()
- Геттеры
- Публичные конструкторы

Рассмотрим это на простом примере:
```java
class Customer {
 private final int age;
 private final String fullName;
 
 Customer (int age, String fullName) {
   this.age = age;
   this.fullName = fullName;
 }
 
 public int getAge() {
   return age;
 }
 
 public String getFullName () {
   return fullName;
 }
 
 @Override
 public boolean equals(Object o) {
   if (this == o) {
     return true;
   }
   if (o == null || getClass() != o.getClass()) {
     return false;
   }
   Customer c = (Customer) o;
   return age == c.age && fullName.equals(c.fullName);
 }
 
 @Override
 public int hashCode() {
   return Objects.hash(age, fullName);
 }
 
 @Override
 public String toString() {
   return new StringJoiner(", ", Customer.class.getSimpleName() + "[", "]")
       .add("age=" + age)
       .add("fullName =" + fullName)
       .toString();
 }
}
```

### Пример с записями (Record)

«Класс записей» (обычно называется просто запись) является сравнительно новой концепцией. Это неизменяемый (в обычном низкоуровневом понимании Java) носитель фиксированного набора значений, известных как компоненты записи (records components). Каждый компонент порождает неизменяемое (final) поле, которое содержит предоставленное значение и метод доступа для извлечения значения. Имена поля и метода доступа совпадают с именем компонента.  
  
Для обеспечения возможности создать новый экземпляр записи, также, создается конструктор, называемый каноническим (canonical constructor), который имеет список параметров, в точности соответствующий объявленному описанию состояния.  
  
Язык программирования Java (как предварительная функциональность (preview feature) в Java 14) предоставляет лаконичный синтаксис для объявления записей, в котором программист должен всего лишь определить типы и имена компонентов, что и определяет запись, например, следующим образом:
```java
record Customer (int age, String fullName) {}
```

### Для чего было необходимо добавление Record в Java?

Основной причиной было улучшение читаемости кода, облегчение расширения и поддержки существующего кода.

Как уже упоминалось выше, очевидные преимущества применения **_Record_**:
- автоматическое создание публичного конструктора (auto-generated public constructor)
- автоматическое создание частных неизменяемых полей (private immutable (i.e. final) fields)
- автоматическое создание методов hashCode(), equals(), и toString()
- автоматическое создание геттеров

Все эти преимущества становятся особенно удобными, когда в существующую структуру данных добавляется новое поле или наоборот убирается из нее. В случае с **_Record_** нет необходимости изменять или переопределять конструктор, поля, геттеры и методы hashCode, equals, toString; всё будет выполнено автоматически без участия разработчика.

Давайте рассмотрим использование Record более подробно.

### Конструктор

Тип **_Record_** по умолчанию имеет так называемый канонический конструктор - тот, который инициализирует все имеющиеся поля.

Мы можем расширить функционал канонического конструктора, добавив к нему желаемое поведение с помощью компактной записи этого конструктора, как в примере ниже:
```java
record Customer(int age, String fullName) {
  public Customer {
    if (age < 0) {
      throw new IllegalArgumentException("Величина, отражающая возраст клиента, должна быть положительным числом");
    }
  }
}
```
Как видно из этого примера, с помощью компактной записи конструктора, можно выполнять валидацию полей и выбрасывать исключения. Однако стоит отметить, что допускаются только unchecked исключения, проверяемые или checked исключения выбросить (throw) не получится.

В дополнение к каноническому конструктору можно создавать свои собственные, однако они обязательно должны ссылаться на другие конструкторы с использованием ключевого слова this:
```java
record Customer (int age, String fullName) {
  public Customer(int age) {
    this(age, “Agent Smith”);
  }
  public Customer() {
    this(100);
  }
}
```

Очевидное применение таких конструкторов – задание значений по-умолчанию.

### Общие классы записей

В Java также можно определить общие классы **_Records_**. Универсальный класс записи — это класс записи, который имеет один или несколько параметров типа. Перед вами пример:
```java
public record Pair<T, U>(T first, U second) {}
```
В этом примере Pair — это универсальный класс записи, который принимает два параметра типа T и U. Экземпляр этой записи мы можем создать следующим образом:
```java
Pair<String, Integer>pair = new Pair<>( "Hello" , 123);
```

### Вложенный класс внутри Record

Внутри записи также можно определить вложенные классы и интерфейсы. Это полезно для группировки связанных классов и интерфейсов, также это может помочь улучшить организацию и удобство сопровождения кодовой базы. Вот пример записи, содержащей вложенный класс:
```java
public record Person(String name, int age, Contact contact){

    public static class Contact {

       private final String email;
       private final String phone;

       public Contact(String email, String phone){
           this.email = email;
           this.phone = phone;
       }

       public String getEmail(){
          return email;
       }

       public String getPhone(){
          return phone;
       }
    }
}
```
В этом примере Person — это запись, содержащая вложенный класс Contact. В свою очередь, Contact — это статический вложенный класс, который содержит два приватных конечных поля: адрес электронной почты и телефон. Он также имеет конструктор, принимающий электронную почту и номер телефона, и два метода получения: getEmail() и getPhone(). Экземпляр Person мы можем создать следующим образом:
```java
Person person = new Person("John",30, new Person.Contact("john@example.com", "123-456-7890"));
```
В этом примере мы создали новый объект Person с именем John, возрастом 30 лет и новый объект Contact с электронной почтой `john@example.com` и телефоном 123-456-7890.

### Вложенный интерфейс внутри Record

Вот пример записи, содержащей вложенный интерфейс:
```java
public record Book(String title, String author, Edition edition){
    public interface Edition{
       String getName();
   }
}
```
В данном примере Book — это запись, содержащая вложенный интерфейс Edition. В свою очередь, Edition — это интерфейс, определяющий единственный метод getName().

Экземпляр Book мы можем создать следующим образом:
```java
Book book = new Book("The Hitchhiker's Guide to the Galaxy", "Douglas Adams", new Book.Edition() {
   public String getName() {
      return "Science Fiction";
   }
});
```
В этом примере мы создаем новый объект Book с заголовком The Hitchhiker's Guide to the Galaxy, автором Douglas Adams и новой анонимной реализацией интерфейса Edition, которая возвращает имя Science Fiction, когда вызывается метод getName().

### hashCode, equals и toString

Хотя **_Reсord_** обеспечивает автоматическое создание и поддержание этих методов в актуальном состоянии, их все же можно переопределить и обеспечить пользовательское поведение, как в примере ниже:
```java
record Customer(int age, String fullName) {
  @Override
  public String toString() {
    return "Переопределенное поведение метода toString";
  }
}
```

### Неизменяемость

Как уже упоминалось ранее, все поля в **_Record_** являются конечными (final), т.е. их изменение не возможно.

Однако используя компактную запись конструктора, мы можем их переопределить на этапе создания:
```java
record Customer (int age, String fullName) {
  public Customer {
    fullName = “Modified Name”;
  }
}
```
Использование ключевого слова this недопустимо. Следующий код приведет к ошибке компиляции:
```java
record Customer (int age, String fullName) {
  public Customer {
    this.fullName = “Modified Name”;
  }
}
```
И так, поскольку **_Record_** является неизменяемым типом, все объекты этого типа, после того как они были созданы, не могут быть изменены.

У **_Record_** не существует сеттеров, поскольку все поля являются конечными и сеттеры не могут быть созданы.

Единственный способ изменить какие-либо данные - создать новый объект:
```java
Customer c1 = new Customer(35, “Nice guy”);
Customer c2 = new Customer(c1.age(), “Friend of that nice guy”);
```

### Расширение функционала с помощью пользовательских методов и полей

Тип **_Record_** поддерживает добавление функционала путем написания собственных методов.

Частный случай, - валидация полей с использованием компактной записи конструктора, уже был рассмотрен ранее в статье.

И так, пример:
```java
record Customer(int age, String fullName) {
  public boolean isAdult() {
    return age >= 18;
  }
}
```
Пользовательские поля можно использовать внутри **_Record_**, только определив их в списке полей заголовка:
```java
sealed class Gender permits Male, Female {}
 
final class Male extends Gender {}
 
final class Female extends Gender {}
 
record Customer(int age, String fullName, Gender gender) {}
```
Поля вне определения записи не разрешены, и следующий код работать не будет:
```java
sealed class Gender permits Male, Female {}
 
final class Male extends Gender {}
 
final class Female extends Gender {}
 
record Customer(int age, String fullName) {
  private final Gender gender;
}
```

### Видимость полей

Особенность **_Record_** для каждого поля создавать публичный геттер является в некоторой степени недостатком, так как делает применение этого типа сфокусированным на данных, а не на поведении.

У вас нет возможности сделать поле private, и следующий код не будет компилироваться:
```java
record Customer(private int age, String fullName) {}
```

### [Сериализация](Serializable)

Объекты типа **_Record_** хорошо подходят для сериализации и десериализации:
```java
record Customer(int age, String fullName) impelements Serializable {}
```
Однако здесь важно отметить, что такие объекты сериализуются иначе, чем обычные сериализуемые или экстернализуемые объекты.

Сериализация объектов **_Record_** не может быть настроена, и любые специфические для класса (class-specific) методы writeObject, readObject, readObjectNoData, writeExternal и readExternal будут игнорироваться при сериализации и десериализации.

### Статические методы и поля

Как и любой другой класс в Java, **_Record_** допускает использование статических методов и полей:
```java
record Customer(int age, String fullName) {
 
  private static final int adultAge = 18;
 
  public boolean isAdult() {
    return age >= adultAge;
  }
 
  public static Customer createAdultCustomer(String fullName){
   return new Customer(adultAge, fullName);
  }
 
}
```

### Наследование

Для того чтобы понять, может ли быть унаследован **_Record_** или может ли он наследовать другие классы, рассмотрим его реализацию «под капотом»:
```java
record Customer (int age, String fullName) {}
```
Если выполнить команду **javap Customer**, получим что-то подобное:
```java
final class Customer extends java.lang.Record {
Customer(int, String);
  public final java.lang.String toString();
  public final int hashCode();
  public final boolean equals(java.lang.Object);
  public int age();
  public String fullName();
}
```
Видим, что класс Customer являются final, поэтому его нельзя унаследовать.

В свою очередь он унаследован от класса java.lang.Record, а поскольку Java не допускает множественного наследования, получается что тип **_Record_** не может наследовать никакие другие классы, в том числе абстрактные.

### Может ли запись реализовывать интерфейсы?

Да, запись в Java может реализовывать интерфейсы.
```java
record Customer(int age, String fullName) implements Comparable<Customer>, Serializable {
  @Override
  public int compareTo(Customer c) {
    return this.age - c.age;
  }
}
```

Например, приведенный ниже код демонстрирует концепцию:
```java
public interface Printable {
   void print();
}

public record Person(String name, int age) implements Printable {
   public void print() {
      System.out.println("Name: " + name + ", Age: " + age);
   }
}
```
Здесь мы определили интерфейс Printable с единственным методом print(). Мы также определили запись Person, которая реализует интерфейс Printable. Запись Person имеет два поля: name и age, и переопределяет метод печати интерфейса Printable для печати значений этих полей.

Мы можем создать экземпляр записи Person и вызвать его метод print следующим образом:
```java
Person person = new Person("John", 30);
person.print();
```
Это выведет на консоль 
<p style="background-color: navy; color: yellow">
Name: John, Age: 30</p>
Как показано в примере, записи в Java могут реализовывать интерфейсы точно так же, как и обычные классы. Это может быть полезно для добавления поведения к записи или для обеспечения соответствия записи контракту, определенному интерфейсом.