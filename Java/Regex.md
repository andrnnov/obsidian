#Java #Regex
### Регулярные выражения ###

2023-12-14 10:55

Пакет java.util.regex предоставляется Java с целью сопоставления регулярных выражений с шаблоном. Регулярные выражения Java характеризуются существенным сходством с языком программирования Perl и очень просты в освоении.

В Java регулярные выражения (regular expression/regex/regexp) представляют собой особую последовательность символов, позволяющую вам сопоставить или выявить другие строки либо их набор, опираясь на специализированный синтаксис в качестве шаблона. Они могут быть использованы для поиска, редактирования либо манипулирования текстом и данными.
Java поддерживает поиск по шаблону посредством своего API Regex.

Пакет java.util.regex исходно состоит из следующих трех классов:
- **Pattern Class** – объект класса Pattern представляет скомпилированное представление регулярного выражения. В классе Pattern публичный конструктор не предусмотрен. Для создания шаблона, вам сперва необходимо вызвать один из представленных публичных статичных методов **compile()**, который далее произведет возврат объекта класса Pattern. Регулярное выражение в данных методах принимается как первый аргумент.
- **Matcher Class** – объект класса Matcher представляет механизм, который интерпретирует шаблон, а также производит операции сопоставления с вводимой строкой. Аналогично классу Pattern, Matcher не содержит публичных конструкторов. Объект класса Matcher может быть получен путем вызова метода **matcher()** на объекте класса Pattern.
- **PatternSyntaxException** – объект класса PatternSyntaxException представляет непроверяемое исключение, которое обозначает синтаксическую ошибку в шаблоне регулярного выражения.

Java также предоставляет поддержку поиска по шаблону посредством различных методов класса [java.lang.String](String). Например, функция [[String#Метод matches() в Java|boolean matches (String regex)]] возвращает `true` только тогда, когда вызывающая строка в точности соответствует регулярному выражению `regex`.

[[String#Метод matches() в Java|matches()]] и другие ориентированные на регулярные выражения удобные методы класса [String](String) "под капотом" реализованы аналогично API Regex.
#### Создание регулярных выражений в Java ####

Чтобы создать RegEx в Java, нужно сделать два простых шага:
1. написать его в виде строки с учётом синтаксиса регулярных выражений;
2. скомпилировать эту строку в регулярное выражение;

Работа с регулярными выражениями в любой Java-программе начинается с создания объекта класса `Pattern`. Для этого необходимо вызвать один из двух имеющихся в классе статических методов `compile`. Первый метод принимает один аргумент – строковый литерал регулярного выражения, а второй – плюс еще параметр, включающий режим сравнения шаблона с текстом:
```java
public static Pattern compile (String literal)
public static Pattern compile (String literal, int flags)
```
[Список](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#CASE_INSENSITIVE) возможных значений параметра `flags` определен в классе `Pattern` и доступен нам как статические переменные класса. Например:
```java
Pattern pattern = Pattern.compile("java", Pattern.CASE_INSENSITIVE);//поиск совпадений с шаблоном будет производиться без учета регистра символов.
```
По сути, класс `Pattern` — это конструктор регулярных выражений. Под «капотом» метод `compile` вызывает закрытый конструктор класса `Pattern` для создания скомпилированного представления. Такой способ создания экземпляра шаблона реализован с целью создания его в виде неизменяемого объекта. При создании производится синтаксическая проверка регулярного выражения. При наличии ошибок в строке – генерируется исключение `PatternSyntaxException`.
#### Синтаксис регулярных выражений ####

Синтаксис регулярных выражений основан на использовании символов `<([{\^-=$!|]})?*+.>`, которые можно комбинировать с буквенными символами. В зависимости от роли их можно разделить на несколько групп:

_1. Метасимволы для поиска совпадений границ строк или текста_

|Метасимвол|Назначение|
|---|---|
|^|начало строки|
|$|конец строки|
|\b|граница слова|
|\B|не граница слова|
|\A|начало ввода|
|\G|конец предыдущего совпадения|
|\Z|конец ввода|
|\z|конец ввода|

_2. Метасимволы для поиска символьных классов_

|Метасимвол|Назначение|
|---|---|
|\d|цифровой символ|
|\D|нецифровой символ|
|\s|символ пробела|
|\S|непробельный символ|
|\w|буквенно-цифровой символ или знак подчёркивания|
|\W|любой символ, кроме буквенного, цифрового или знака подчёркивания|
|.|любой символ|

_3. Метасимволы для поиска символов редактирования текста_

|Метасимвол|Назначение|
|---|---|
|\t|символ табуляции|
|\n|символ новой строки|
|\r|символ возврата каретки|
|\f|переход на новую страницу|
|\u 0085|символ следующей строки|
|\u 2028|символ разделения строк|
|\u 2029|символ разделения абзацев|

_4. Метасимволы для группировки символов_

|Метасимвол|Назначение|
|---|---|
|[абв]|любой из перечисленных (а,б, или в)|
|[^абв]|любой, кроме перечисленных (не а,б, в)|
|[a-zA-Z]|слияние диапазонов (латинские символы от a до z без учета регистра )|
|[a-d[m-p]]|объединение символов (от a до d и от m до p)|
|[a-z&&[def]]|пересечение символов (символы d,e,f)|
|[a-z&&[^bc]]|вычитание символов (символы a, d-z)|

_5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов._

|Метасимвол|Назначение|
|---|---|
|?|один или отсутствует|
|`*`|ноль или более раз|
|+|один или более раз|
|{n}|n раз|
|{n,}|n раз и более|
|{n,m}|не менее n раз и не более m раз|

##### Жадный режим квантификатора #####

Особенностью квантификаторов является возможность использования их в разных режимах: жадном, сверхжадном и ленивом. **Сверхжадный режим** включается добавлением символа «`+`» после квантификатора, а ленивый – символа «`?`». Например:
```java
"А.+а" // жадный режим
"А.++а" // сверхжадный режим
"А.+?а" // ленивый режим
```
Попробуем на примере этого шаблона разобраться в работе квантификаторов в различных режимах. По умолчанию квантификатор работает в жадном режиме. Это означает, что он ищет максимально длинное совпадение в строке (Поиск производит одновременно от первого и от последнего символа до совпадения). В результате выполнения этого кода:
```java
public static void main(String[] args) {
    String text = "Егор Алла Александр";
    Pattern pattern = Pattern.compile("А.+а");
    Matcher matcher = pattern.matcher(text);
    while (matcher.find()) {
        System.out.println(text.substring(matcher.start(), matcher.end()));
    }
}
```
мы получим такой вывод:<p style="background-color: navy; color: yellow"> Алла Алекса</p>
##### Сверхжадный режим квантификатора #####

В сверхжадном режиме работа матчера аналогична механизму жадного режима. Отличие состоит в том, что при захватывании текста до конца строки поиск в обратном направлении не происходит. То есть первые три этапа при сверхжадном режиме будут аналогичны жадному режиму. После захвата всей строки матчер добавляет остаток шаблона и сравнивает с захваченной строкой. В нашем примере при выполнении метода main с шаблоном "`А.++а`" совпадений не будет найдено.
##### Ленивый режим квантификатора #####

В этом режиме на начальном этапе, как и в жадном режиме, ищется совпадение с первым символом шаблона. При его нахождении, ищется второй символ. Если строка еще не закончилась, то производится новый цикл поиска и т.д.
В результате работы метода `main` при использовании шаблона "`А.+?а`" мы получим следующий результат: 
<p style="background-color: navy; color: yellow">Алла<br>
Алекса</p>
Как видно из нашего примера, при использовании разных режимов квантификатора для одного и того же шаблона мы получили разные результаты. Поэтому необходимо учитывать эту особенность и выбирать нужный режим в зависимости от желаемого результата при поиске.
#### Экранирование символов в регулярных выражениях ####

Поскольку регулярное выражение в Java, а точнее — его исходное представление задается с помощью строкового литерала, необходимо учитывать те правила спецификации Java, которые касаются строковых литералов. В частности, символ обратной косой черты «`\`» в строковых литералах в исходном коде Java интерпретируется как символ управляющей последовательности, который предупреждает компилятор, что следующий за ним символ — специальный и что его нужно особым образом интерпретировать. Например:
```java
String s = "The root directory is \nWindows";//перенос Windows на новую строку
String s = "The root directory is \u00A7Windows";//вставка символа параграфа перед Windows
```
Поэтому в строковых литералах, которые описывают регулярное выражение, и используют символ «`\`» (например, для метасимволов) **его нужно удваивать**, чтобы компилятор байт-кода Java не интерпретировал его по-своему. Например:
```java
String regex = "\\s"; // шаблон для поиска символов пробела
String regex = "\"Windows\""; // шаблон для поиска строки "Windows"
```
Двойной символ обратной косой черты также следует использовать для экранирования символов, задействованных в качестве специальных, если мы планируем их использовать как «обычные» символы. Например:
```java
String regex = "How\\?"; // шаблон для поиска строки “How?”
```
#### Группы сбора ####

Группы сбора представляют способ обращения с несколькими символами как с одной единицей. Они создаются путем размещения символов, которые предстоит сгруппировать, в серии круглых скобок. К примеру, регулярное выражение (dog) составляет отдельную группу, содержащую буквы "d", "o", и "g".

Группы сбора нумеруются посредством определения числа открывающих круглых скобок слева направо. Так, в выражении ((A)(B(C))) присутствуют четыре подобные группы:
- ((A)(B(C)))
- (A)
- (B(C))
- (C)

Для определения числа групп, представленных в выражении, вызвать метод groupCount на объекте класса matcher в Java. Метод groupCount извлекает число типа int, отображающее количество групп сбора, представленных в сопоставляемом шаблоне.

Также имеется специальная группа, группа 0, которая во всех случаях представляет выражение в полном виде. Данная группа не включается в сумму, представленную методом groupCount.
#### Пример ####

Ниже рассмотрен пример регулярного выражения в Java, иллюстрирующий способ выявления строки цифр в представленных буквенно-цифровых строках.
```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches {
   public static void main( String args[] ) {
      // Строка для сканирования, чтобы найти шаблон
      String str = "Крещение Руси произошло в 988 году! Не так ли?";
      String pattern = "(.*)(\\d+)(.*)";

      // Создание Pattern объекта
      Pattern r = Pattern.compile(pattern);
      // Создание matcher объекта
      Matcher m = r.matcher(str);
      if (m.find( )) {
         System.out.println("Найдено значение: " + m.group(0));
         System.out.println("Найдено значение: " + m.group(1));
         System.out.println("Найдено значение: " + m.group(2));
      }else {
         System.out.println("НЕ СОВПАДАЕТ");
      }
   }
}
```
В итоге будет получен следующий результат:
<p style="background-color: navy; color: yellow">Найдено значение: Крещение Руси произошло в 988 году! Не так ли?<br>
Найдено значение: Крещение Руси произошло в 98<br>
Найдено значение: 8</p>
#### Методы класса Pattern ####

В классе `Pattern` есть и другие методы для работы с регулярными выражениями: 
String pattern() – возвращает исходное строковое представление регулярного выражения, из которого был создан объект `Pattern`:
```java
Pattern pattern = Pattern.compile("abc");
System.out.println(Pattern.pattern())//"abc"
```
static boolean matches(String regex, CharSequence input) – позволяет проверить регулярное выражение, переданное в параметре regex на соответствие тексту, переданному в параметре `input`. Возвращает: _true_ – если текст соответствует шаблону; _false_ – в противном случае; Пример:
```java
System.out.println(Pattern.matches("А.+а","Алла"));//true
System.out.println(Pattern.matches("А.+а","Егор Алла Александр"));//false
```
int flags() – возвращает значения параметра `flags` шаблона, которые были установлены при его создании, или 0, если этот параметр не был установлен. Пример:
```java
Pattern pattern = Pattern.compile("abc");
System.out.println(pattern.flags());// 0
Pattern pattern = Pattern.compile("abc",Pattern.CASE_INSENSITIVE);
System.out.println(pattern.flags());// 2
```
String[] split(CharSequence text, int limit) – разбивает текст, переданный в качестве параметра на массив элементов `String`. Параметр `limit` определяет предельное количество совпадений, которое ищется в тексте:
- при `limit>0` – выполняется поиск `limit-1` совпадений;
- при `limit<0` – выполняется поиск всех совпадений в тексте
- при `limit=0` – выполняется поиск всех совпадений в тексте, при этом пустые строки в конце массива отбрасываются;
Пример:
```java
public static void main(String[] args) {
    String text = "Егор Алла Анна";
    Pattern pattern = Pattern.compile("\\s");
    String[] strings = pattern.split(text,2);
    for (String s : strings) {
        System.out.println(s);
    }
    System.out.println("---------");
    String[] strings1 = pattern.split(text);
    for (String s : strings1) {
        System.out.println(s);
    }
}
```
Вывод на консоль: 
<p style="background-color: navy; color: yellow">Егор<br>
Алла<br>
Анна<br>
--------<br>
Егор<br>
Алла<br>
Анна</p>
#### Методы класса Matcher ####

Далее представлен список полезных методов экземпляра класса.
##### Методы индексов ####

Методы индексов представляют полезные значения индекса, которые демонстрируют точное количество соответствий, обнаруженных во вводимой строке.

|   |   |
|---|---|
|№.|Метод и описание|
|1|**public int start()**  <br>Возврат начального индекса к предыдущему совпадению.|
|2|**public int start(int group)**  <br>Возврат начального индекса к последовательности, захваченной данной группой в течение предыдущей операции установления соответствия.|
|3|**public int end()**  <br>Возврат позиции смещения следом за последним совпадающим символом.|
|4|**public int end(int group)**  <br>Возврат позиции смещения следом за последним символом к последовательности, захваченной данной группой в течение предыдущей операции установления соответствия.|
##### Методы исследования #####

Методы исследования производят анализ вводимой строки и возврат булевого значения, отображающего наличие либо отсутствие шаблона.

|   |   |
|---|---|
|№.|Метод и описание|
|1|**public boolean lookingAt()**  <br>Предпринимает попытку поиска соответствия вводимой последовательности в начале области с шаблоном.|
|2|**public boolean find()**  <br>Предпринимает попытку поиска следующей подпоследовательности в вводимой последовательности, соответствующей шаблону.|
|3|**public boolean find(int start)**  <br>Сброс данного поиска соответствия и попытка поиска новой подпоследовательности в вводимой последовательности, соответствующей шаблону с указанного индекса.|
|4|**public boolean matches()**  <br>Предпринимает попытку поиска совпадений во всей области с шаблоном.|

##### Методы замены #####

Методы замены представляют полезные методы для замены текста во вводимой строке.

|   |   |
|---|---|
|№.|Метод и описание|
|1|**public Matcher appendReplacement(StringBuffer sb, String replacement)**  <br>Производит нетерминальное присоединение и замену.|
|2|**public StringBuffer appendTail(StringBuffer sb)**  <br>Производит терминальное присоединение и замену.|
|3|**[public String replaceAll(String replacement)](replaceAll())**  <br>Заменяет каждую подпоследовательность в вводимой последовательности, совпадающей с шаблоном, указанным в замещающей строке.|
|4|**[public String replaceFirst(String replacement)](replaceFirst())**  <br>Замещает первую подпоследовательность в вводимой последовательности, совпадающей с шаблоном, указанным в замещающей строке.|
|5|**public static String quoteReplacement(String s)**  <br>Возвращает литеральную замену Строки для указанной Строки. Данный метод производит сроку, которая будет функционировать в качестве литеральной замены s в методе appendReplacement класса Matcher.|

##### Методы start и end #####

Далее представлен пример, в котором производится подсчет количества раз, когда в строке ввода встречается слово "кот".
```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches {
   private static final String REGEX = "\\bкот\\b";
   private static final String INPUT = "кот кот кот котёл кот";

   public static void main( String args[] ) {
      Pattern p = Pattern.compile(REGEX);
      Matcher m = p.matcher(INPUT);   // получение matcher объекта
      int count = 0;

      while(m.find()) {
         count++;
         System.out.println("Номер вхождения: "+count);
         System.out.println("Начальная позиция вхождения: "+m.start());
         System.out.println("Конечная позиция вхождения: "+m.end());
      }
   }
}
```
В итоге будет получен следующий результат:
<p style="background-color: navy; color: yellow">Номер вхождения: 1<br>
Начальная позиция вхождения: 0<br>
Конечная позиция вхождения: 3<br>
Номер вхождения: 2<br>
Начальная позиция вхождения: 4<br>
Конечная позиция вхождения: 7<br>
Номер вхождения: 3<br>
Начальная позиция вхождения: 8<br>
Конечная позиция вхождения: 11<br>
Номер вхождения: 4<br>
Начальная позиция вхождения: 18<br>
Конечная позиция вхождения: 21</p>

Как видим, в данном примере используются границы слов с целью удостоверения в том, что буквы "к" "о" "т" не являются частью другого слова. Также отображаются определенные полезные сведения касательно нахождения совпадения во вводимой строке.

Метод start производит возврат начального индекса в последовательности, захваченной в данной группе в ходе предыдущей операции поиска совпадений, а end производит возврат индекса к последнему совпавшему символу, плюс один.
##### Методы matches и lookingAt #####

Оба метода matches и lookingAt направлены на попытку поиска соответствия вводимой последовательности с шаблоном. Разница, однако, заключается в том, что для метода matches требуется вся вводимая последовательность, в то время как lookingAt этого не требует.

Оба метода всегда начинаются в начале вводимой строки. Далее представлен пример, рассматривающий их функциональность.
```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches {

   private static final String REGEX = "Pro";
   private static final String INPUT = "ProgLang";
   private static Pattern pattern;
   private static Matcher matcher;

   public static void main( String args[] ) {
      pattern = Pattern.compile(REGEX);
      matcher = pattern.matcher(INPUT);

      System.out.println("Текущее регулярное выражение: " + REGEX);
      System.out.println("Текущие входные данные: " + INPUT);

      System.out.println("lookingAt(): " + matcher.lookingAt());
      System.out.println("matches(): " + matcher.matches());
   }
}
```
В итоге будет получен следующий результат:
<p style="background-color: navy; color: yellow">Текущее регулярное выражение: Pro<br>
Текущие входные данные: ProgLang<br>
lookingAt(): true<br>
matches(): false</p>
##### Методы replaceFirst и replaceAll #####

Методы [replaceFirst](replaceFirst()) и [replaceAll](replaceAll()) производят замену текста, который совпадает с заданным регулярным выражением. Исходя из их названия, replaceFirst производит замену первого совпадения, а replaceAll производит замену остальных совпадений.

Далее представлен пример, поясняющий их функциональность.
```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches {
   private static String REGEX = "Собака";
   private static String INPUT = "Собака говорит мяу.";
   private static String REPLACE = "Кот";

   public static void main(String[] args) {
      Pattern p = Pattern.compile(REGEX);
      
      // получение matcher объекта
      Matcher m = p.matcher(INPUT); 
      INPUT = m.replaceAll(REPLACE);
      System.out.println(INPUT);
   }
}
```

В итоге будет получен следующий результат:
<p style="background-color: navy; color: yellow">Кот говорит мяу.</p>
##### Методы appendReplacement и appendTail #####

Класс Matcher также предоставляет методы замены текста appendReplacement и appendTail.
Далее представлен пример, поясняющий их функциональность.

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches {
   private static String REGEX = "а*д";
   private static String INPUT = "аадProgLangааадProgLangадProgLangд";
   private static String REPLACE = "-";
   public static void main(String[] args) {

      Pattern p = Pattern.compile(REGEX);
      // получение matcher объекта
      Matcher m = p.matcher(INPUT);
      StringBuffer sb = new StringBuffer();
      while(m.find()) {
         m.appendReplacement(sb, REPLACE);
      }
      m.appendTail(sb);
      System.out.println(sb.toString());
   }
}
```
В итоге будет получен следующий результат:
<p style="background-color: navy; color: yellow">-ProgLang-ProgLang-ProgLang-</p>
#### Методы класса PatternSyntaxException ####

PatternSyntaxException представляет непроверяемое исключение, которое отображает синтаксическую ошибку в шаблоне регулярного выражения. Класс PatternSyntaxException представлен следующими методами, которые помогут определить вам ошибку.

|   |   |
|---|---|
|№.|Метод и описание|
|1|**public String getDescription()**  <br>Представляет описание ошибки.|
|2|**public int getIndex()**  <br>Представляет индекс ошибки.|
|3|**public String getPattern()**  <br>Представляет шаблон регулярного выражения, содержащего ошибку.|
|4|**public String getMessage()**  <br>Производит возврат многострочной строки, содержащей описание синтаксической ошибки и ее индекс, ошибочный образец регулярного выражения, а также визуальную индикацию индекса ошибки в шаблоне.|

