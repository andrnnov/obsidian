#Java #static
### Модификатор static в Java ###

Модификатор **static** - переводится как "статичный", "постоянный", "неизменный". Действительно, его задача - сделать переменную или метод "независимыми" от объекта.

Если метод (переменная) имеет модификатор **static**, то это значит, что она объявляется **для класса**. Без этого модификатора - для объектов. Из-за того, что статический метод/переменная связана с классом, а не объектом, их можно вызывать **без создания объекта класса**.
#### Модификатор static для полей ####

##### Принцир 1 #####

Представим, что у нас есть класс Car и класс Test, в котором лежит метод main, из которого мы обращаемся к классу Car:
```java
public class Test{
	public static void main (String args[]){
	}
}

public class Car{
}
```
Представим, что в классе Car лежат две переменные - одна статическая, а другая нет:
```java
public class Car{
  static int myStatic = 100;
  int notStatic = 0;
}
```
Теперь, создадим в нашем главном классе - классе Test - новый объект класса Car:
```java
public class Test{
	public static void main (String args[]){
		Car myCar = new Car();
	}
}
```
Давайте теперь обратимся к нашим переменным - статической myStatic и "обычной" notStatic. Мы можем свободно их использовать - например, выводить на экран:
```java
public class Test{
	public static void main (String args[]){
		Car myCar = new Car();
		
		System.out.println(myCar.myStatic);
		System.out.println(myCar.notStatic);
	}
}
```
Мы получим:
==100
0==
А теперь давайте попробуем выполнить тот же код, но уже без создания объекту класса (т.е. вычеркнем строчку "**Car myCar = new Car();**"):
```java
public class Test{
	public static void main (String args[]){
		System.out.println(Car.myStatic);
		System.out.println(Car.notStatic);
	}
}
```
Код работать не будет, потому что ко второй переменной - **notStatic** - нельзя обращаться без создания объекта. Но если попробовать вывести только первую переменную - **myStatic** - код будет правильным:
```java
public class Test{
	public static void main (String args[]){
		System.out.println(Car.myStatic);
	}
}
```
Дело в том, что, как мы уже говорили, к статическим переменным **можно обращаться без создания объекта класса**.
##### Принцип 2 #####

**static** - переменная с этим модификатором **одна для всех  объектов класса**.
Представим, что у нас есть тот же класс - Car:
```java
public class Car{
  static int myStatic = 100;
  int notStatic = 0;
}
```
В классе Test увеличим значение статической переменной и выведем её на экран:
```java
public class Test{
	public static void main (String args[]){
		Car.myStatic += 20;
		System.out.println(Car.myStatic);
	}
}
```
Значение переменной **myStatic** увеличится - и она будет равна **120**.
Теперь, создадим новый объект класса Car:
```java
public class Test{
	public static void main (String args[]){
		Car.myStatic += 20;
		System.out.println(Car.myStatic);
		Car c1 = new Car();
	}
}
```
Что случится, если вывести на экран переменные нового объекта c1?
```java
public class Test{
	public static void main (String args[]){
		Car.myStatic += 20;
		System.out.println(Car.myStatic);
		Car c1 = new Car();
		System.out.println("Статическая переменная c1 = "+c1.myStatic);
		System.out.println("Не статическая переменная c1 = "+c1.notStatic);
}
```
Мы получим:
==**Статическая переменная c1 = 120;**
**Не статическая переменная c1 = 0;**==

То есть не смотря на создание нового объекта, наше статическое поле не изменилось. Но такого бы не произошло с "обычной"переменной **notStatic**, которая каждый раз создается заново. Посмотрим на следующий код:
```java
public class Test{
	public static void main (String args[]){
		Car.myStatic += 20;
		System.out.println(Car.myStatic);
		Car c1 = new Car();
		System.out.println("Статическая переменная c1 = "+c1.myStatic);
		c1.notStatic +=20;  
		System.out.println("Не статическая переменная c1 = "+c1.notStatic);
		Car c2 = new Car();
	}
}
```
 Теперь переменные равны **120** и **20**. Кроме того, у нас есть новый объект класса Car - c2. Как Вы считаете, чему будет равны переменные **myStatic** и **notStatic** для нового объекта?
```java
public class Test{
	public static void main (String args[]){
		Car.myStatic += 20;
		System.out.println(Car.myStatic);
		Car c1 = new Car();
		System.out.println("Статическая переменная c1 = "+c1.myStatic);
		c1.notStatic +=20;  
		System.out.println("Не статическая переменная c1 = "+c1.notStatic);
		Car c2 = new Car();
		System.out.println("Статическая переменная c2 = "+c2.myStatic);  
		System.out.println("Не статическая переменная c2 = "+c2.notStatic);
	}
}
```
Результат будет следующим:
==**Статическая переменная c1 = 120;**
**Не статическая переменная c1 = 20;**
**Статическая переменная c2 = 120;**
**Не статическая переменная c2 = 0;**==
Видно, что статическая переменная имеет одинаковое значение, а не статическая - разные. Это происходит потому, что не статическая переменная "создается заново" для каждого объекта, а статическая является **общей для всех объектов класса**.
#### Модификатор static в Java: методы ####

##### Метод вызывается без создания объекта класса #####

Как и в случае с полями, статические методы можно вызывать без создания объекта. Например, представим, что у нас есть класс MyClass -  а внутри его два метода, статический и "обычный":
```java
class MyClass{
	public static void firstMethod (){
		System.out.println("Это статический метод!");
	}
	public void secondMethod (){
		System.out.println("Это НЕ статический метод!");
	}
}
```
Мы можем вызвать оба метода, создав объект класса MyClass:
```java
class Test {
	public static void main (String args[]){
		MyClass c1 = new MyClass();
		c1.firstMethod();
		c1.secondMethod();
	}
}
```
Тут мы заменили название объекта - **c1** - на название класса (ведь ни одного объекта теперь у нас нет! Как Вы думаете, что произойдет? Естественно, такой код работать не будет. Дело в том, что так обращаться можно только к одному из этих методов - статическому:
```java
class Test {
	public static void main (String args[]){
    MyClass.firstMethod();
	}
}
```
##### Статические методы нельзя переопределять #####

Как Вы помните, один из фундаментальных принципов ООП - это "наследование". Дело в том, что в случаях, когда нам нужно создать новый класс, который имеет много общих свойств с каким-то уже существующим, вместо того, чтобы писать все заново, можно сделать "наследника" существующего класса. Этот "наследник" будет иметь те же самые метод и переменные, что и "родитель".

Тем не менее, в классе-наследнике обычно можно **переопределять** существующие методы. Это значит, что можно создать метод с таким же названием, только заменить его "внутренности". Так вот, **статический** метод нельзя переопределить. По аналогии с переменными, можно сказать, что этот метод "один для класса и его наследников" - так же, как статическая переменная "одна для класса и всех его объектов".
##### Статическим методам нужен "статический контекст" #####

Есть такое правило: **статический метод не может ссылаться на нестатическую переменную**. Что это значит?

Представьте, что у нас в каком-то классе есть статический метод. То есть это метод, к которому, как Вы знаете, **можно обращаться без создания объекта класса**. Это значит, что если статический метод будет обращаться к нестатическим переменным (которые попросту "не будут существовать", потому что объект не объявлен), то возникнет ошибка. Поэтому, **статические методы могут ссылаться только на статические переменные**. Это гарантирует, что во время выполнения нашего метода все элементы будут инициализированы и будут работать. Именно это и называется "статическим контекстом".

#### Зачем применяется модификатор static ####

- Если Вам нужно иметь **доступ к переменной или методу** без создания экземпляра класса. Например, представим, что у нас есть класс Cat. Логически, нет смысла делать статической переменную "имя кошки" - ведь оно будет индивидуальным для каждого экземпляра класс - т.е. для каждого кота. И метод "мяукать" делать статическим нет смысла - ведь без кошки (без создания объекта класса) вроде как некому будет мяукать ! Но если представить, что у нас есть класс Math, в котором будет метод "найти корень квадратный". Это метод мы можем сделать статическим - ведь он нам явно очень пригодится, и будет часто использоваться. А зачем писать две строчки кода (создание экземпляра класса + вызов метода), если можно обойтись одной (вызов метода)? При этом, класс Math не несет никакой логическом нагрузки, в отличии от классов Cat, Dog или Car, и нам совершенно не нужен объект Math чтобы находить квадратные корни !

- У статических переменных и методов есть еще одно полезное свойство - они **общие для всех экземпляров класса**. С одной стороны, это перекликается с установкой констант. Например, представьте, что у нас есть класс Cat, в котором есть два поля - "количество_лап" и "количество_хвостов". Понятно, что для всех экземпляров этого класса переменная "количество_лап" будет равна 4, а "количество_хвостов" равна 1. Мы можем сделать эти поля static, потому что они будут общими. Кроме того, это нам поможет сэкономить память, потому что эти переменные не будут "создаваться заново" для каждого экземпляра. Наоборот, все эти экземпляры будут ссылаться на одну и ту же - статическую - переменную. Тот факт, что статическая переменная общая для всех классов, можно использовать и по-другому. Например, представьте, что у нас есть класс Dog. В этом классе, у нас будет статическая переменная "количество_собак", и мы сделаем так, чтобы каждый раз при создании объекта класса Dog она увеличивалась на 1. Таким образом, мы сможем  посчитать, сколько мы создавали объектов! Или, как вариант, эту цифру можно использовать для присвоения уникального идентификационного номера каждой собаке.