#java #GUI #Swing 

## Библиотека Swing

2024-05-07 10:58

### Java [AWT](AWT)

Первой попыткой Sun создать графический интерфейс для Java была библиотека **[AWT](AWT)** (Abstract Window Toolkit) — инструментарий для работы с различными оконными средами. Sun сделал прослойку на Java, которая вызывает методы из библиотек, написанных на С. Библиотечные методы AWT создают и используют графические компоненты операционной среды. С одной стороны, это хорошо, так как программа на Java похожа на остальные программы в рамках одной ОС. Но при запуске ее на другой платформе могут возникнуть различия в размерах компонентов и шрифтов, которые будут портить внешний вид программы.

Чтобы обеспечить мультиплатформенность **[AWT](AWT)** интерфейсы вызовов компонентов были унифицированы, вследствие чего их функциональность получилась немного урезанной. Да и набор компонентов получился довольно небольшой. Так например, в [AWT](AWT) нет таблиц, а в кнопках не поддерживается отображение иконок. Тем не менее пакет **java.awt** входит в Java с самого первого выпуска и его можно использовать для создания графических интерфейсов.

Таким образом, компоненты **[AWT](AWT)** не выполняют никакой "работы". Это просто «Java-оболочка» для элементов управления той операционной системы, на которой они работают. Все запросы к этим компонентам перенаправляются к операционной системе, которая и выполняет всю работу.

Использованные ресурсы **[AWT](AWT)** старается освобождать автоматически. Это немного усложняет архитектуру и влияет на производительность. Написать что-то серьезное с использованием AWT будет несколько затруднительно. Сейчас ее используют разве что для апплетов.

### Java Swing

Swing в Java — это инструментарий графического интерфейса пользователя (GUI), включающий компоненты GUI.

Swing предоставляет богатый выбор виджетов и пакетов для создания изысканных компонентов GUI для Java-приложений.

Swing является частью **Java Foundation Classes** (JFC). **JFC** представляет собой API для программирования GUI на Java, обеспечивающий графический интерфейс пользователя.

Библиотека **Java Swing** построена поверх **Java Abstract Widget Toolkit** (AWT). Можно использовать простые компоненты программирования графического интерфейса Java:
- кнопки;
- метки;
- выпадающие списки;
- текстовые поля и т.д.,

### Принцип Lightweight

Принцип «Lightweight» означает, что Swing компоненты прорисовываются самими компонентами в родительском окне (например, на [JFrame](JFrame)), без использования компонентов операционной системы. В отличие от «тяжелых» компонентов [AWT](AWT), Swing приложение может иметься только одно окно.

В приложении могут сочетаться компоненты Swing и [AWT](AWT). Но это может порождать некоторые проблемы — в частности, компоненты [AWT](AWT) всегда перекрывают Swing элементы, а также закрывают собой всплывающие меню JPopupMenu и JComboBox. Для предотвращения этого, у данного типа компонентов имеются методы setLightWeightPopupEnabled (boolean), позволяющие запретить использование «легковесных» всплывающих элементов. При установке данного свойства в true AWT элементы не будут перекрывать меню.

Основным минусом таких «легковесных» (lightweight) компонентов является относительно медленная работа. Положительная сторона — универсальность интерфейса созданных приложений на всех платформах.

### Look and Feel

Архитектура **Swing** разработана таким образом, что можно изменять «look and feel» (L&F) приложения. «Look» определяет внешний вид компонентов, а «Feel» — их поведение. JRE предоставляет следующие L&F:
- CrossPlatformLookAndFeel — родной для приложений Java L&F, иначе называется Metal; используется по умолчанию и обеспечивает стандартное поведение компонентов и их внешний вид, вне зависимости от платформы.
- SystemLookAndFeel — родной для системы L&F; системный L&F определяется во время выполнения. Для Windows используется «Windows» L&F, который имитирует особенности конкретной системы, на которой запущен. Для Linux и Solaris используется «GTK+», если установлен GTK+ 2.2 или более поздняя версия, в противном случае используется «Motif».
- Synth — это основа для создания собственных L&F.
- Multiplexing — предоставляет возможность использования различных L&F одновременно.

Таким образом, компоненты Swing поддерживают специфические динамически подключаемые виды и поведения (plugable look-and-feel), благодаря которым возможна адаптация интерфейса приложения к графическому интерфейсу платформы. То есть к компоненту можно динамически подключить другой, специфический для операционной системы. Таким образом, приложения, использующие Swing, могут выглядеть как "родные" приложения для данной операционной системы.

### Иерархия Swing

![[java-Swing.jpg]]

### Контейнерный класс

Любой класс, в котором есть другие компоненты, называется контейнерным классом. Для создания приложений с графическим интерфейсом необходим как минимум один класс контейнеров.

Ниже приведены три типа контейнерных классов:
1. Панель – используется для организации компонентов в окне.
2. Рамка – полностью функционирующее окно со значками и заголовками.
3. Диалог – это как всплывающее окно, но не полностью функциональное, как рамка.

### Swing контейнеры высшего уровня

Для создания графического интерфейса приложения необходимо использовать специальные компоненты библиотеки Swing, называемые контейнерами высшего уровня (top level containers). Они представляют собой окна операционной системы, в которых размещаются компоненты пользовательского интерфейса. К контейнерам высшего уровня относятся окна [JFrame](JFrame) и [JWindow](JWindow), диалоговое окно [JDialog](JDialog), а также апплет JApplet (который не является окном, но тоже предназначен для вывода интерфейса в браузере, запускающем этот апплет). Контейнеры высшего уровня Swing представляют собой тяжеловесные компоненты и являются исключением из общего правила. Все остальные компоненты Swing являются легковесными.

Простой **Swing** пример создания оконного интерфейса **JFrame**.
```java
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.JLabel;

public class JFrameTest {
    public static void createGUI() {
        JFrame frame = new JFrame("Test frame");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        JLabel label = new JLabel("Test label");
        frame.getContentPane().add(label);
        
        frame.setPreferredSize(new Dimension(200, 100));
        
        frame.pack();
        frame.setVisible(true);          
   }
   
   public static void main(String[] args) {
       JFrame.setDefaultLookAndFeelDecorated(true);
       javax.swing.SwingUtilities.invokeLater(new Runnable() {
           public void run() {
               createGUI();
           }
       });
   }
}
```
Конструктор **JFrame()** без параметров создает пустое окно. Конструктор **JFrame(String title)** создает пустое окно с заголовком title. Чтобы создать простейшую программу с пустым окном необходимо использовать следующие методы:
- setSize(int width, int height) - определение размеров окна;
- setDefaultCloseOperation(int operation) - определение действия при завершении программы;
- setVisible(boolean visible) - сделать окно видимым.

Если не определить размеры окна, то оно будет иметь нулевую высоту независимо от того, что в нем находится. Размеры окна включают не только «рабочую» область, но и границы и строку заголовка.

Метод setDefaultCloseOperation определяет действие, которое необходимо выполнить при "выходе из программы". Для этого следует в качестве параметра operation передать константу EXIT_ON_CLOSE, описанную в классе [JFrame](JFrame).

По умолчанию окно создается невидимым. Для отображения окна на экране вызывается метод setVisible с параметром true. Если вызвать его с параметром false, окно станет невидимым.

Графический интерфейс **java swing** примера создания окна **[JFrame](JFrame)** представлен на следующем рисунке:
![[Ex4-Swing.png]]

### Корневая панель JRootPane

Каждый раз, как только создается контейнер высшего уровня, будь то обычное окно, диалоговое окно или апплет, в конструкторе этого контейнера создается **корневая панель JRootPane**. Контейнеры высшего уровня Swing следят за тем, чтобы другие компоненты не смогли "пробраться" за пределы JRootPane.

Корневая панель **JRootPane** добавляет в контейнеры свойство "глубины", обеспечивая возможность не только размещать компоненты один над другим, но и при необходимости менять их местами, увеличивать или уменьшать глубину расположения компонентов. Такая возможность необходима при создании многодокументного приложения **Swing**, у которого окна представляют легковесные компоненты, располагающиеся друг над другом, а также выпадающими (контекстными) меню и всплывающими подсказками.

На следующем рисунке наглядно представлена структура корневой панели **JRootPane**.
![[swing-rootpane.png]]
Корневая панель **JRootPane** представляет собой контейнер, унаследованный от базового класса Swing JComponent. В этом контейнере за расположение компонентов отвечает специальный менеджер расположения, реализованный во внутреннем классе RootPaneLayout. Этот менеджер расположения отвечает за то, чтобы все составные части корневой панели размещались так, как им следует: многослойная панель занимает все пространство окна; в ее слое FRAME_CONTENT_LAYER располагаются строка меню и панель содержимого, а над всем этим располагется прозрачная панель.

Все составляющие корневой панели **JRootPane** можно получить или изменить. Для этого у нее есть набор методов get/set. Программным способом **JRootPane** можно получить с использованием метода getRootPane().

Кроме контейнеров высшего уровня корневая панель применяется во внутренних окнах JInternalFrame, создаваемых в многодокументных приложениях и располагающихся на "рабочем столе" JDesktopPane. Это позволяет забыть про то, что данные окна представляют собой обычные легковесные компоненты, и работать с ними как с настоящими контейнерами высшего уровня.

### Многослойная панель JLayeredPane

В основании корневой панели (контейнера) лежит так называемая многослойная панель **JLayeredPane**, занимающая все доступное пространство контейнера. Именно в этой панели располагаются все остальные части корневой панели, в том числе и все компоненты пользовательского интерфейса.

**JLayeredPane** используется для добавления в контейнер свойства глубины (depth). To есть, многослойная панель позволяет организовать в контейнере третье измерение, вдоль которого располагаются слои (layers) компонента. В обычном контейнере расположение компонента определяется прямоугольником, который показывает, какую часть контейнера занимает компонент. При добавлении компонента в многослойную панель необходимо указать не только прямоугольник, занимаемый компонентом, но и слой, в котором он будет располагаться. Слой в многослойной панели определяется целым числом. Чем больше определяющее слой число, тем выше слой находится.

Первый добавленный в контейнер компонент оказывается выше компонентов, добавленных позже. Чаще всего разработчик не имеет дело с позициями компонентов. При добавлении компонентов их положение меняются автоматически. Тем не менее многослойная панель позволяет менять позиции компонентов динамически, уже после их добавления в контейнер.

Возможности многослойной панели широко используются некоторыми компонентами **Swing**. Особенно они важны для многодокументных приложений, всплывающих подсказок и меню. Многодокументные **Swing** приложения задействуют специальный контейнер **JDesktopPane** («рабочий стол»), унаследованный от **JLayeredPane**, в котором располагаются внутренние окна Swing. Самые важные функции многодокументного приложения — расположение «активного» окна над другими, сворачивание окон, их перетаскивание — обеспечиваются механизмами многослойной панели. Основное преимущество от использования многослойной панели для всплывающих подсказок и меню — это ускорение их работы. Вместо создания для каждой подсказки или меню нового тяжеловесного окна, располагающегося над компонентом, в котором возник запрос на вывод подсказки или меню, **Swing** создает быстрый легковесный компонент. Этот компонент размещается в достаточно высоком слое многослойной панели выше в стопке всех остальных компонентов и используется для вывода подсказки или меню.

Многослойная панель позволяет организовать неограниченное количество слоев. Структура **JLayeredPane** включает несколько стандартных слоев, которые и используются всеми компонентами Swing, что позволяет обеспечить правильную работу всех механизмов многослойной панели. Стандартные слои JLayeredPane представлены на следующем рисунке.
![[swing-layeredpane.png]]
**Default**

Слой Default используется для размещения всех обычных компонентов, которые добавляются в контейнер. В этом слое располагаются внутренние окна многодокументных приложений.

**Palette**

Слой Palette предназначен для размещения окон с набором инструментов, которые обычно перекрывают остальные элементы интерфейса. Создавать такие окна позволяет панель JDesktopPane, которая размещает их в этом слое.

**Modal**

Слой Modal планировался для размещения легковесных модальных диалоговых окон. Однако такие диалоговые окна пока не реализованы, так что этот слой в Swing в настоящее время не используется.

**Popup**

Наиболее часто используемый слой, служащий для размещения всплывающих меню и подсказок.

**Drag**

Самый верхний слой. Предназначен для операций перетаскивания (drag and drop), которые должны быть хорошо видны в интерфейсе программы.

Небольшой пример JLayeredPane с многослойной панелью показывает, как добавлять компоненты в различные слои и как слои располагаются друг над другом:
```java
import javax.swing.*;
import java.awt.*;

// класс рисования двух типов фигур с текстом
class Figure extends JComponent {
    private static final long serialVersionUID = 1L;
    private Color color;
    private int type;
    private String text;
    // параметры: цвет и тип фигуры
    Figure(Color color, int type, String text) {
        this.color = color;
        this.type = type;
        this.text = text;
        setOpaque(false);
    }
    public void paintComponent(Graphics g) {
        // прорисовка фигуры
        g.setColor(color);
        switch (type) {
        case 0: g.fillOval(0, 0, 90, 90); break;
        case 1: g.fillRect(0, 0, 130, 80); break;
        }
        g.setColor(Color.yellow);
        g.drawString(text, 10, 35);
    }
}
public class JLayeredPaneTest extends JFrame {
    private static final long serialVersionUID = 1L;

    public JLayeredPaneTest() {
        // создание окна
        super("Example LayeredTest");
        // выход при закрытии окна
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        // определение многослойной панели
        JLayeredPane lp = getLayeredPane();
        // создание трех фигур
        Figure figure1 = new Figure(Color.red , 0, "Figure popup");
        Figure figure2 = new Figure(Color.blue, 0, "Figure 1");
        Figure figure3 = new Figure(Color.cyan, 1, "Figure 2");
        // определение местоположения фигур в окне
        figure1.setBounds(10, 40, 120, 120);
        figure2.setBounds(60, 120, 160, 180);
        figure3.setBounds(90, 55, 250, 180);
        // добавление фигур в различные слои
        lp.add(figure1, JLayeredPane.POPUP_LAYER  );
        lp.add(figure2, JLayeredPane.PALETTE_LAYER);
        lp.add(figure3, JLayeredPane.PALETTE_LAYER);
        // смена позиции одной из фигур
        lp.setPosition(figure3, 0);
        // определение размера и открытие окна
        setSize(280, 250);
        setVisible(true);
    }
    public static void main(String[] args) {
        JFrame.setDefaultLookAndFeelDecorated(true);
        new JLayeredPaneTest();
    }
}
```
В примере создается небольшое окно **[JFrame](JFrame)** и в многослойную панель добавляется несколько компонентов Figure. Чтобы получить многослойную панель в любом контейнере Swing высшего уровня, достаточно вызвать метод **getLayeredPane()**.

Вспомогательный класс Figure наследует свойства базового класса JComponent и позволяет различными цветами рисовать фигуры двух типов (круги и прямоугольники). Параметры для прорисовки фигур задаются в конструкторе класса.

При определении интерфейса создаются три фигуры разного цвета (два круга и прямоугольник). Круг размещается в слое POPUP_LAYER, а прямоугольники — в слое PALETTE_LAYER. При размещении компонентов указываются их абсолютные экранные координаты, потому что в многослойной панели обычные менеджеры расположения не работают.

В завершении позиция одного из прямоугольников меняется так, чтобы он был первым в слое, хотя изначально добавлялся вторым. Запустив приложение, вы увидите, что многослойная панель работает и аккуратно располагает компоненты согласно их слоям и позициям.
![[Ex5-Swing.png]]
В обычных приложениях многослойная панель редко используется напрямую, в них она выполняет свои функции незаметно. Тем не менее, иногда она помогает создать удивительные эффекты и необычные интерфейсы, позволяя, например, разместить поверх обычных компонентов анимацию или видео, не требуя для этого от разработчика нечеловеческих усилий и ухищрений.

### Панель содержимого ContentPane

Панель содержимого ContentPane - это следующая часть корневой панели, которая используется для размещения компонентов пользовательского интерфейса программы. **ContentPane** занимает большую часть пространства многослойной панели (за исключением места, занимаемого строкой меню). Чтобы панель содержимого не закрывала добавляемые впоследствии в окно компоненты, многослойная панель размещает ее в специальном очень низком слое с названием FRAME_CONTENT_LAYER, с номером -30000.

Обратиться к панели содержимого можно методом **getContentPane()** класса [JFrame](JFrame). С помощью метода add(Component component) можно добавить на нее любой элемент управления. Заменить **ContentPane** любой другой панелью типа [JPanel](JPanel) можно методом **setContentPane()**

Пример добавления кнопки в панель содержимого:
```java
JButton newButton = new JButton(); 
getContentPane().add(newButton);
```

### Разница между AWT и Swing

|                                                       |                                         |
| ----------------------------------------------------- | --------------------------------------- |
| AWT                                                   | SWING                                   |
| - платформо-зависимая                                 | - не зависит                            |
| - не соответствует MVC                                | - соответствует MVC                     |
| - меньше компонентов                                  | - Более мощные компоненты               |
| - Не поддерживает подключаемый внешний вид и ощущение | - Поддержка подключаемого внешнего вида |
| - тяжеловесный                                        | - легкий                                |

### Элементы пользовательского интерфейса SWING

Ниже приведен список часто используемых элементов управления при разработке графического интерфейса с использованием SWING.

| S.No. | Класс и описание                                                                                                                                                                                                                 |
| ----- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | [JLabel](JLabel)<br>Объект JLabel - это компонент для размещения текста в контейнере.                                                                                                                                            |
| 2     | [JButton](JButton)<br>Этот класс создает кнопку с надписью.                                                                                                                                                                      |
| 3     | [JColorChooser](https://www.tutorialspoint.com/swing/swing_jcolorchooser.htm)<br>JColorChooser предоставляет панель элементов управления, предназначенную для того, чтобы пользователь мог манипулировать цветом и выбирать его. |
| 4     | [Флажок JCheck Box](https://www.tutorialspoint.com/swing/swing_jcheckbox.htm)<br>JCheckBox - это графический компонент, который может находиться либо в состоянии **включено** (true), либо в состоянии **выключено** (false).   |
| 5     | [JRadioButton](https://www.tutorialspoint.com/swing/swing_jradiobutton.htm)<br>The JRadioButton class is a graphical component that can be in either an **on** (true) or **off** (false) state. in a group.                      |
| 6     | [JList](https://www.tutorialspoint.com/swing/swing_jlist.htm)<br>A JList component presents the user with a scrolling list of text items.                                                                                        |
| 7     | [JComboBox](https://www.tutorialspoint.com/swing/swing_jcombobox.htm)<br>Компонент JComboBox предоставляет пользователю доступное меню выбора.                                                                                   |
| 8     | [JTextField](https://www.tutorialspoint.com/swing/swing_jtextfield.htm)<br>Объект JTextField - это текстовый компонент, который позволяет редактировать одну строку текста.                                                      |
| 9     | [JPasswordField](https://www.tutorialspoint.com/swing/swing_jpasswordfield.htm)<br>Объект JPasswordField - это текстовый компонент, предназначенный для ввода пароля.                                                            |
| 10    | [JTextArea](https://www.tutorialspoint.com/swing/swing_jtextarea.htm)<br>Объект JTextArea - это текстовый компонент, который позволяет редактировать несколько строк текста.                                                     |
| 11    | [[Icon#Класс ImageIcon\|ImageIcon]]<br>Элемент управления ImageIcon - это реализация интерфейса Icon, который рисует значки из изображений                                                                                       |
| 12    | [JScrollBar](https://www.tutorialspoint.com/swing/swing_jscrollbar.htm)<br>Элемент управления полосой прокрутки представляет собой компонент полосы прокрутки, позволяющий пользователю выбирать из диапазона значений.          |
| 13    | [JOptionPane](JOptionPane)<br>JOptionPane предоставляет набор стандартных диалоговых окон, которые запрашивают у пользователей значение или информируют их о чем-либо.                                                           |
| 14    | [JFileChooser](https://www.tutorialspoint.com/swing/swing_jfilechooser.htm)<br>Элемент управления JFileChooser представляет собой диалоговое окно, в котором пользователь может выбрать файл.                                    |
| 15    | [JProgressBar](https://www.tutorialspoint.com/swing/swing_jprogressbar.htm)<br>По мере продвижения задачи к завершению на индикаторе выполнения отображается процент выполнения задачи.                                          |
| 16    | [JSlider](https://www.tutorialspoint.com/swing/swing_jslider.htm)<br>JSlider позволяет пользователю графически выбирать значение, перемещая ручку в пределах ограниченного интервала.                                            |
| 17    | [JSpinner](https://www.tutorialspoint.com/swing/swing_jspinner.htm)<br>JSpinner - это однострочное поле ввода, которое позволяет пользователю выбрать число или значение объекта из упорядоченной последовательности.            |
| 18    | [JToggleButton](JToggleButton) - реализация кнопки с двумя состояниями.                                                                                                                                                          |



**Пример 1.** В примере реализуется простейший GUI непосредственно в главном методе _main_():
```java
import javax.swing.*; // подключаем все средства java Swing
 
public class Program { // класс с методом main()
    public static void main(String[] args) {
        JFrame frame = new JFrame("My First GUI"); 
        // Для окна нужна "рама" - Frame
        // стандартное поведение при закрытии окна - завершение приложения
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(300, 300); // размеры окна
        frame.setLocationRelativeTo(null); // окно - в центре экрана
        JButton button = new JButton("Press"); // Экземпляр класса JButton
        // getContentPane() - клиентская область окна
        frame.getContentPane().add(button); // Добавляем кнопку на Frame
        frame.setVisible(true); // Делаем окно видимым
    }
}
```
**Вывод:**
![[Ex1-Swing.png]]
После запуска можно увидеть, что кнопка «Press» заполнила всю клиентскую область окна. 
Как это исправить? Для этого служит менеджер компоновки. Он используется для компоновки (или расположения) компонентов GUI Java внутри контейнера. Существует множество менеджеров компоновки, но наиболее часто используемые из них — это **BorderLayout**, который размещает компоненты в пяти областях:
- cверху (NORTH);
- снизу (SOUTH);
- слева (WEST);
- справа (EAST);
- по центру (CENTER).

**Пример 2.** Добавим ещё одну кнопку. Теперь их будет две. Первую переименуем в «Старт», а вторую назовём «Стоп»:
```java
import java.awt.BorderLayout; // подключаем BorderLayout
import javax.swing.*; // подключаем все средства java Swing
 
public class Program { // класс с методом main()
 
    public static void main(String[] args) {
        JFrame frame = new JFrame("My First GUI");
        // добавляем панель
        JPanel buttonsPanel = new JPanel(); 
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(300, 300);
        frame.setLocationRelativeTo(null); // окно в центре экрана
        JButton start = new JButton("Старт");
        JButton stop = new JButton(("Стоп");
        // добавляем кнопки на панель
        buttonsPanel.add(start);
        buttonsPanel.add(stop);
        // размещаем панель на Frame (верхняя часть)
        frame.getContentPane().add(BorderLayout.NORTH, buttonsPanel);
        frame.setVisible(true);
    }
}
```
**Вывод:**
![[Ex2-Swing.png]]
Таким образом можно создавать нужное количество невидимых панелей и размещать (add) на них необходимое число компонентов.

**Пример 3.**
```java
import javax.swing.*;  
  
class SwingDemo {  
    SwingDemo() {  
        JFrame frame = new JFrame("A simple swing program");  
        frame.setSize(275, 100);  
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
        JLabel label = new JLabel("Swing");  
        frame.getContentPane().add(label);  
        frame.setVisible(true);  
    }  
    public static void main(String[] args) {  
        SwingUtilities.invokeLater(new Runnable() {  
            public void run() {  
                new SwingDemo();  
            }  
        });  
    }  
}
```
**Вывод:**
![[Ex3-Swing.png]]
В программе SwingDemo присутствует строка
```java
frame.getContentPane().add(label);
```
В JDK5 и более поздних версиях ее можно заменить на
```java
frame.add(label);
```
В методе main конструктор SwingDemo вызывается с помощью следующего фрагмента кода:
```java
    public static void main(String[] args) {  
        SwingUtilities.invokeLater(new Runnable() {  
            public void run() {  
                new SwingDemo();  
            }  
        });  
    }  
```
Этот фрагмент кода создает объект SwingDemo не в основном потоке приложения, а в потоке обработки событий.

Метод main выполняется в основном потоке событий. Следовательно, в нем нельзя непосредственно создавать объект. Следует сначала создать объект [Runnable](Runnable), выполняемый в потоке обработки событий, а затем предоставить данному объекту возможность создавать окно интерфейса программы.