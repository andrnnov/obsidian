#Java #Synchronized
### Монитор и synchronized ###

2023-12-26 10:00

[Мютекс](mutex) («mutual exclusion» — «взаимное исключение») – это специальный объект для синхронизации процессов. Он может принимать два состояния – занят и свободен.
Если упростить, то мютекс – это boolean-переменная, которая принимает два значения: занят(true) и свободен(false).

Когда процесс хочет монопольно владеть некоторым объектом, она помечает его мютекс занятым, а когда закончила работу с ним – помечает его мютекс свободным. **[Мютекс](Mutex) прикреплен к каждому объекту в Java.** От программиста он скрыт. А работать с мютексом в Java можно посредством монитора. **Прямой доступ к мютексу есть только у Java-машины.**

>Монитор – это специальный механизм (кусок кода) который гарантирует, что только один поток может выполнять данный раздел (или разделы) кода в любой момент времени.

Надстройка над мютексом, который обеспечивает правильную работу с ним. Ведь мало пометить, что объект занят, надо еще обеспечить, чтобы другие потоки не пробовали воспользоваться занятым объектом.

**В Java монитор реализован с помощью ключевого слова synchronized.**

Блок synchronized, то компилятор Java заменяет его тремя кусками кода:
1. В начале блока synchronized добавляется код, который отмечает мютекс как занятый.
2. В конце блока synchronized добавляется код, который отмечает мютекс как свободный.
3. Перед блоком synchronized добавляется код, который смотрит, если мютекс занят – то поток должен ждать его освобождения.

Все immutable объекты являются thread-safe. Все объекты, к которым происходит обращение из разных потоков, должны быть thread-safe (безопасен).

Только методы и блоки могут быть синхронизированы, но не переменные и классы. Если метод, в котором содержится критически важная «многопоточная» логика, статический, синхронизация будет осуществляться по классу.

#### Монитор статического синхронизированного класса ####

Монитор – это доступ к блоку кода - synchronized. Если создаем экземпляр статического вложенного класса, - все что можно достать из объекта – принадлежит статическому классу.

Память для статического метода выделяется только один раз во время загрузки класса. Это означает, что при выполнении статического метода **весь класс блокируется**.

Таким образом, **другие статические синхронизированные методы также блокируются**.

Если один поток выполняет статический синхронизированный метод, все остальные потоки, пытающиеся выполнить любые статические синхронизированные методы, будут заблокированы.

#### Монитор нестатического синхронизированного класса ####

Что является монитором у нестатического синхронизированного класса? – Объект.

В случае нестатического синхронизированного метода память выделяется многократно при каждом вызове метода.

#### Синхронизация ####

>Синхронизация это механизм, позволяющий обеспечить целостность какого-либо ресурса (файл, данные в памяти), когда он используется несколькими процессами или потоками в случайном порядке.

Синхронизация это процесс, который позволяет выполнять потоки параллельно.

В Java все объекты имеют одну блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. Если поток получил блокировку, ни один другой поток не может войти в синхронизированный код, пока блокировка не будет снята. Когда поток, владеющий блокировкой, выходит из синхронизированного кода, блокировка снимается. Теперь другой поток может получить блокировку объекта и выполнить синхронизированный код. Если поток пытается получить блокировку объекта, когда другой поток владеет блокировкой, поток ждет пока блокировка не снимется.

Объявить метод синхронизированным можно только тогда, когда вся логика внутри него выполняется одним потоком одновременно.
**Объект**
```java
public void myMethod() {
	private Object key = new Object();
	synchronized (key) {
		System.out.println("Hi I'm synchronized block!");
		}
	}
```
**Метод**
```java
synchronized void myMethod() {
	System.out.println("Hi I'm synchronized method!");
}
```
**Статический метод**
```java
static void myMethod() {
	synchronized(MyObject.class) {
		System.out.println("Hi I'm synchronized method!");
	}
}
```
**Недостаток** использования synchronized является как раз то, что другие **потоки вынуждены ждать**, пока нужный объект или метод освободится. Это создает так называемый "bottle neck" ("узкое место") в программе - и скорость работы может пострадать.


```java
public class Program {
 
    public static void main(String[] args) {
        CommonResource commonResource= new CommonResource();
        for (int i = 1; i < 6; i++){
            Thread t = new Thread(new CountThread(commonResource));
            t.setName("Thread "+ i);
            t.start();
        }
    }
}
 
class CommonResource{
    int x=0;
}

class CountThread implements Runnable{
    CommonResource res;
    CountThread(CommonResource res){
        this.res=res;
    }
    public void run(){
        synchronized(res){
            res.x=1;
            for (int i = 1; i < 5; i++){
                System.out.printf("%s %d \n", Thread.currentThread().getName(), res.x);
                res.x++;
                try{
                    Thread.sleep(100);
                }
                catch(InterruptedException e){}
            }
        }
    }
}
```
При создании синхронизированного блока кода после оператора `synchronized` идет объект-заглушка: `synchronized(res)`. Причем в качестве объекта может использоваться только объект какого-нибудь класса, но не примитивного типа.

Каждый объект в Java имеет ассоциированный с ним монитор. Монитор представляет своего рода инструмент для управления доступа к объекту. Когда выполнение кода доходит до оператора synchronized, монитор объекта res блокируется, и на время его блокировки монопольный доступ к блоку кода имеет только один поток, который и произвел блокировку. После окончания работы блока кода, монитор объекта res освобождается и становится доступным для других потоков.

После освобождения монитора его захватывает другой поток, а все остальные потоки продолжают ожидать его освобождения.

В итоге консольный вывод примет вид:
<p style="background-color: navy; color: yellow">
Thread 1 1<br>
Thread 1 2<br>
Thread 1 3<br>
Thread 1 4<br>
Thread 3 1<br> 
Thread 3 2<br>
Thread 3 3<br>
Thread 3 4<br>
Thread 5 1 <br>
Thread 5 2<br>
Thread 5 3<br>
Thread 5 4<br>
Thread 4 1<br>
Thread 4 2<br>
Thread 4 3<br>
Thread 4 4<br>
Thread 2 1 <br>
Thread 2 2<br>
Thread 2 3<br>
Thread 2 4</p>
При применении оператора `synchronized` к методу пока этот метод не завершит выполнение, монопольный доступ имеет только один поток - первый, который начал его выполнение. Для применения synchronized к методу, изменим классы программы:
```java
public class Program {
    public static void main(String[] args) {
        CommonResource commonResource= new CommonResource();
        for (int i = 1; i < 6; i++){             
            Thread t = new Thread(new CountThread(commonResource));
            t.setName("Thread "+ i);
            t.start();
        }
    }
}
 
class CommonResource {
    int x;
    synchronized void increment(){
        x=1;
        for (int i = 1; i < 5; i++){
            System.out.printf("%s %d \n", Thread.currentThread().getName(), x);
            x++;
            try{
                Thread.sleep(100);
            }
            catch(InterruptedException e){}
        }
    }
}
 
class CountThread implements Runnable{
    CommonResource res;
    CountThread(CommonResource res){
        this.res=res;
    }
     
    public void run(){
        res.increment();
    }
}
```
Результат работы в данном случае будет аналогичен примеру выше с блоком synchronized. Здесь опять в дело вступает монитор объекта CommonResource - общего объекта для всех потоков. Поэтому синхронизированным объявляется не метод `run()` в классе CountThread, а метод `increment` класса CommonResource. Когда первый поток начинает выполнение метода increment, он захватывает монитор объекта CommonResource. А все потоки также продолжают ожидать его освобождения.