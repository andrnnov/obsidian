#Java #TextBlock

## [Руководство программиста по текстовым блокам](https://docs.oracle.com/en/java/javase/17/text-blocks/index.html)

2024-07-29 14:34

[JEP 378](http://openjdk.java.net/jeps/378) добавляет языковую функцию _текстовые блоки_ в Java SE 15 и более поздних версиях. Хотя в JEP эта функция объясняется очень подробно, не всегда очевидно, как эту функцию можно и нужно использовать. В этом руководстве собраны практические рекомендации по использованию текстовых блоков, а также некоторые рекомендации по стилю.

## Введение

_Основной задачей_ текстового блока является обеспечение ясности путем минимизации синтаксиса Java, необходимого для отображения строки, занимающей несколько строк.

В более ранних выпусках JDK для встраивания многострочных фрагментов кода требовалась путаница явных ограничителей строк, конкатенаций строк и разделителей. Текстовые блоки устраняют большинство этих препятствий, позволяя вам вставлять фрагменты кода и текстовые последовательности более или менее как есть.

Текстовый блок - это альтернативная форма представления строк Java, которая может использоваться везде, где можно использовать традиционный строковый литерал в двойных кавычках. Например:
```java
// Using a literal string
String dqName = "Pat Q. Smith";

// Using a text block
String tbName = """
                Pat Q. Smith""";
```
Объект, созданный из текстового блока, представляет собой a [java.lang.String](String) с теми же характеристиками, что и традиционная строка в двойных кавычках. Это включает представление объекта и интернирование. Продолжаем с `dqName` и `tbName` из приведенных выше примеров,
```java
// Both dqName and tbName are strings of equal value
dqName.equals(tbName)    // true

// Both dqName and tbName intern to the same string
dqName == tbName         // true
```
Текстовые блоки можно использовать везде, где может использоваться строковый литерал. Например, текстовые блоки могут быть перемешаны со строковыми литералами в выражении объединения строк:
```java
String str = "The old";
String tb = """
            the new""";
String together = str + " and " + tb + ".";
```
Текстовые блоки могут использоваться в качестве аргумента метода:
```java
System.out.println("""
    This is the first line
    This is the second line
    This is the third line
    """);
```
Строковые методы могут быть применены к текстовому блоку:
```java
"""
John Q. Smith""".substring(8).equals("Smith")    // true
```

Текстовый блок может использоваться вместо строкового литерала для улучшения читаемости и ясности кода. В первую очередь это происходит, когда строковый литерал используется для представления многострочной строки. В этом случае возникает значительный беспорядок из-за кавычек, экранирования новой строки и операторов объединения:
```java
// ORIGINAL
String message = "'The time has come,' the Walrus said,\n" +
                 "'To talk of many things:\n" +
                 "Of shoes -- and ships -- and sealing-wax --\n" +
                 "Of cabbages -- and kings --\n" +
                 "And why the sea is boiling hot --\n" +
                 "And whether pigs have wings.'\n";
```
Использование текстовых блоков устраняет большую часть беспорядка:
```java
// BETTER
String message = """
    'The time has come,' the Walrus said,
    'To talk of many things:
    Of shoes -- and ships -- and sealing-wax --
    Of cabbages -- and kings --
    And why the sea is boiling hot --
    And whether pigs have wings.'
    """;
```

### Использование текстовых блоков

#### Синтаксис текстовых блоков

Текстовый блок начинается с трех символов, заключенных в двойные кавычки, за которыми следует символ окончания строки. Вы не можете поместить текстовый блок в одну строку, а содержимое текстового блока не может следовать за тремя открывающими двойными кавычками без разделителя строки. Причина этого в том, что текстовые блоки в первую очередь предназначены для поддержки многострочных строк, и использование начального разделителя строк упрощает правила обработки отступов (см. Раздел ниже, _[[TextBlock#Случайные пробелы|Случайные пробелы]]_).
```java
// ERROR
String name = """Pat Q. Smith""";

// ERROR
String name = """red
                 green
                 blue
                 """;

// OK
String name = """
    red
    green
    blue
    """;
```
Этот последний пример эквивалентен следующему строковому литералу:
```java
String name = "red\n" +
              "green\n" +
              "blue\n";
```
Вот пример фрагмента Java-кода внутри текстового блока:
```java
String source = """
    String message = "Hello, World!";
    System.out.println(message);
    """;
```
Обратите внимание, что нет необходимости экранировать встроенные двойные кавычки. Эквивалентный строковый литерал будет:
```java
String source = "String message = \"Hello, World!\";\n" +
                "System.out.println(message);\n";
```

#### Эта Последняя новая строка

Обратите внимание, что приведенный выше пример,
```java
String name = """
    red
    green
    blue
    """;
```
эквивалентно `"red\ngreen\nblue\n"`. Что делать, если вы хотите представить многострочную строку без этого финала `\n`?
```java
String name = """
    red
    green
    blue""";
```
Этот текстовый блок эквивалентен is `"red\ngreen\nblue"`. Таким образом, размещение закрывающего разделителя на последней видимой строке эффективно удаляет последнюю `\n`.

#### Случайные пробелы

В идеале текстовый блок должен иметь отступ, соответствующий отступу окружающего кода. Например:
```java
void writeHTML() {
    String html = """
        <html>
            <body>
                <p>Hello World.</p>
            </body>
        </html>
        """;
    writeOutput(html);
}
```
Однако возникает вопрос о том, как пробелы, используемые для отступов, влияют на содержимое строки. Наивная интерпретация включала бы все эти пробелы в текстовый блок. Следствием будет то, что переиндентирование кода повлияет на содержимое текстового блока. Вполне вероятно, что это ошибка.

Чтобы избежать этой проблемы, текстовый блок отличает _второстепенный_ пробел от _существенного_ пробела. Компилятор Java автоматически удаляет второстепенный пробел. Отступ слева от `<html>` и `</html>` считается случайным, поскольку эти строки имеют наименьший отступ. Таким образом, они эффективно определяют левое поле текста в текстовом блоке. Однако отступ `<body>` относительно `<html>` _не_ считается случайным пробелом. Предположительно, этот относительный отступ предназначен для того, чтобы быть частью содержимого строки.

В приведенном ниже примере используется "`·`" для визуализации случайного пробела, при этом существенный пробел показан как фактический пробел.
```java
void writeHTML() {
    String html = """
········<html>
········    <body>
········        <p>Hello World.</p>
········    </body>
········</html>
········""";
    writeOutput(html);
}
```
После удаления случайного пробела результирующее содержимое текстового блока выглядит следующим образом:
```
<html>
    <body>
        <p>Hello World.</p>
    </body>
</html>
```
Алгоритм определения случайных пробелов подробно описан в JEP 378. Тем не менее, конечный результат довольно прост. Все содержимое текстового блока сдвигается влево до тех пор, пока в строке с наименьшим начальным пробелом не останется начального пробела.

Чтобы сохранить некоторое количество пробелов и не допустить, чтобы это считалось случайным пробелом, просто сдвиньте строки содержимого текстового блока вправо, сохранив закрывающий разделитель в тройных кавычках на отступе, соответствующем окружающему коду. Например:
```java
void writeHTML() {
    String html = """
········    <html>
········        <body>
········            <p>Hello World.</p>
········        </body>
········    </html>
········""";
    writeOutput(html);
}
```
приводит к следующему:
```
    <html>
        <body>
            <p>Hello World.</p>
        </body>
    </html>
```
Текстовый блок может _отказаться_ от случайного удаления пробелов, установив закрывающий разделитель в позиции первого символа исходной строки:
```java
void writeHTML() {
    String html = """
                  <html>
                      <body>
                          <p>Hello World.</p>
                      </body>
                  </html>
""";
    writeOutput(html);
}
```
В результате не остается случайных пробелов, которые удаляются, и строка включает начальный пробел в каждой строке.
```
                  <html>
                      <body>
                          <p>Hello World.</p>
                      </body>
                  </html>
```
Этот метод контроля размера сохраняемого отступа работает только в том случае, если последняя строка текстового блока заканчивается разделителем строк. Если последняя строка _не_ заканчивается разделителем строк, вам нужно использовать `String::indent` для явного управления отступом. В следующем примере,
```java
String colors = """
    red
    green
    blue""";
```
все отступы рассматриваются как случайные и удаляются:
```
red
green
blue
```
Чтобы включить некоторый отступ в содержимое строки, вызовите метод `indent` для текстового блока:
```java
String colors = """
    red
    green
    blue""".indent(4);
```
Это приводит к:
```
    red
    green
    blue
```

#### Завершающий пробел

Завершающий пробел в каждой строке текстового блока также считается случайным и удаляется компилятором Java. Это сделано для того, чтобы содержимое текстового блока всегда было визуально различимо. Если бы это не было сделано, текстовый редактор, который автоматически удаляет завершающие пробелы, мог бы незаметно изменить содержимое текстового блока.

Если вам нужно, чтобы в текстовом блоке оставался пробел, вы можете использовать одну из следующих стратегий:
```java
// character substitution
String r = """
    trailing$$$
    white space
    """.replace('$', ' ');

// character fence
String s = """
    trailing   |
    white space|
    """.replace("|\n", "\n");

// octal escape sequence for space
String t = """
    trailing\040\040\040
    white space
    """;
```

>**Примечание:** `\u0020` не может использоваться, поскольку экранирующие элементы Unicode переводятся заранее, во время чтения исходного файла, до лексического анализа. Напротив, экранирование символов и строк, такое как `\040`, обрабатывается после того, как лексический анализ разделил исходный файл на токены и идентифицировал строковые литералы и текстовые блоки.

#### Обнаружение потенциальных проблем с пробелами

В предыдущих примерах все отступы состояли из пробелов. Однако иногда люди используют символы табуляции `\t`. К сожалению, компилятор Java не может знать, как символы табуляции отображаются в разных редакторах. Таким образом, правило заключается в том, что каждый отдельный символ пробела обрабатывается одинаково. Одиночный пробел обрабатывается так же, как и одиночный символ табуляции, даже несмотря на то, что последний может привести к появлению пробела, эквивалентного восьми пробелам, при отображении в какой-либо конкретной системе.

Отсюда следует, что смешивание пробелов может иметь противоречивые и непреднамеренные эффекты. Рассмотрим следующий пример, в котором некоторые строки имеют отступы пробелами, а некоторые - табуляцией (которые визуализируются с помощью `␉`).:
```java
    String colors = """
····················red
␉   ␉   ␉   ␉   ␉   green
····················blue""";
```
В этом случае удаление случайных отступов было бы неравномерным, поскольку во второй строке всего пять пробелов, а в остальных - двадцать. Результат будет выглядеть примерно так:
```
               red
green
               blue
```

Можно обнаружить проблемы, связанные со случайными пробелами, включив обнаружение ворсинок текстовых блоков с помощью флага lint компилятора Java, `-Xlint:text-blocks`. Если включено обнаружение ворсинок, то в приведенном выше примере будет выдано предупреждение "несогласованный отступ пробела".

Этот флаг lint также включает другое предупреждение "завершающий пробел будет удален", которое будет выдаваться, если в любой строке текстового блока есть завершающий пробел. Если вам нужно сохранить завершающий пробел, используйте один из методов экранирования или замены, описанных в разделе выше.

#### Нормализация ограничителей строк

Одна из сложностей многострочного строкового литерала заключается в том, что используемый в исходном файле ограничитель строки (`\n`, `\r` или `\r\n`) варьируется от платформы к платформе. Редакторы на разных платформах могут незаметно изменять терминаторы строк. Или, если исходный файл редактируется на разных платформах, текстовый блок может содержать смесь разных терминаторов строк. Это, вероятно, приведет к запутанным и противоречивым результатам.

Чтобы избежать этих проблем, компилятор Java принимает все терминаторы строк в текстовом блоке равными `\n`, независимо от того, какие терминаторы строк на самом деле присутствуют в исходном файле. Следующий текстовый блок (где `␊` и `␍` представляют `\n` и `\r`):
```java
String colors = """
    red␊
    green␍
    blue␍␊
    """;
```
эквивалентно этому строковому литералу:
```java
String colors = "red\ngreen\nblue\n";
```
Если требуется ограничитель строки платформы, то `String::replaceAll("\n", System.lineSeparator())` можно использовать.

#### Перевод Escape-последовательностей

Как и в случае со строковыми литералами, текстовые блоки распознают управляющие последовательности, `\b`, `\f`, `\n` `\t`, `\r` `\"`, `\'` `\\`,,, и восьмеричные управляющие символы. В отличие от строковых литералов, экранирующие последовательности часто не требуются. В большинстве случаев вместо управляющих последовательностей можно использовать настоящие символы `\n`, `\t`, `\"` и `\'`. Следующий текстовый блок (где `␉` и `␊` представляют `\t` и `\n`):
```java
String s = """
    Color␉   Shape␊
    Red␉ ␉   Circle␊
    Green␉   Square␊
    Blue␉␉   Triangle␊
    """;
```
приводит к:
```
Color␉  Shape␊
Red␉ ␉  Circle␊
Green␉  Square␊
Blue␉␉  Triangle␊
```
Экранирование требуется, когда три или более двойных кавычек встречаются последовательно.
```java
String code = """
    String source = \"""
        String message = "Hello, World!";
        System.out.println(message);
        \""";
    """;
```
Экранирующий перевод выполняется как последний этап обработки компилятором Java, поэтому вы можете обойти этапы нормализации ограничителя строки и удаления пробелов, используя явные экранирующие последовательности. Например:
```java
String s = """
           red  \040
           green\040
           blue \040
           """;
```
гарантировало бы, что все строки будут одинаковой длины, поскольку `\040` не переводится в пробел до тех пор, пока не будет удален завершающий пробел ("`·`" используется для отображения завершающего пробела). В результате получается:
```
red···
green·
blue··
```
>**Примечание:** Как отмечалось ранее, управляющая последовательность Unicode `\u0020` _не_ может использоваться в качестве замены для `\040`.

#### Новые управляющие последовательности

`\<line-terminator>` Управляющая последовательность явно подавляет включение неявного символа новой строки.

Например, обычной практикой является разбиение очень длинных строковых литералов на конкатенации меньших подстрок, а затем жесткое перенос результирующего строкового выражения в несколько строк.
```java
  String literal = "Lorem ipsum dolor sit amet, consectetur adipiscing " +
                   "elit, sed do eiusmod tempor incididunt ut labore " +
                   "et dolore magna aliqua.";
```
С помощью `\<line-terminator>` управляющей последовательности это может быть выражено как;
```java
  String text = """
                Lorem ipsum dolor sit amet, consectetur adipiscing \
                elit, sed do eiusmod tempor incididunt ut labore \
                et dolore magna aliqua.\
                """;
```
`\s` Escape-последовательность simple переводится в пробел (`\040`, 32 символ ASCII, пробел.) Поскольку управляющие последовательности не переводятся до тех пор, пока не будет удален пробел в инциденте, `\s` может действовать как ограждение для предотвращения удаления завершающего пробела. Использование `\s` в конце каждой строки в следующем примере гарантирует, что длина каждой строки составляет ровно шесть символов.
```java
String colors = """
    red  \s
    green\s
    blue \s
    """;
```

### Рекомендации по стилю для текстовых блоков

**_G1. Вы должны использовать текстовый блок, когда он улучшает ясность кода, особенно с многострочными строками._**
```java
// ORIGINAL
String message = "'The time has come,' the Walrus said,\n" +
                 "'To talk of many things:\n" +
                 "Of shoes -- and ships -- and sealing-wax --\n" +
                 "Of cabbages -- and kings --\n" +
                 "And why the sea is boiling hot --\n" +
                 "And whether pigs have wings.'\n";

// BETTER
String message = """
    'The time has come,' the Walrus said,
    'To talk of many things:
    Of shoes -- and ships -- and sealing-wax --
    Of cabbages -- and kings --
    And why the sea is boiling hot --
    And whether pigs have wings.'
    """;
```

**_G2. Если строка помещается в одну строку без конкатенации и экранированных новых строк, вам, вероятно, следует продолжать использовать строковый литерал._**
```java
// ORIGINAL - is a text block helpful here?
String name = """
              Pat Q. Smith""";

// BETTER - a string literal works fine
String name = "Pat Q. Smith";
```
**_G3. Используйте встроенные управляющие последовательности, когда они сохраняют читабельность._**
```java
var data = """
    Name | Address | City
    Bob Smith | 123 Anytown St\nApt 100 | Vancouver
    Jon Brown | 1000 Golden Place\nSuite 5 | Santa Ana
    """;
```

**_G4. Для большинства многострочных строк поместите открывающий разделитель в правый конец предыдущей строки, а закрывающий разделитель разместите на отдельной строке, на левом поле текстового блока._**
```java
String string = """
    red
    green
    blue
    """;
```

**_G5. Избегайте выравнивания открывающих и закрывающих разделителей и левого поля текстового блока. При изменении имени переменной или модификаторов требуется переиндентировать текстовый блок._**
```java
// ORIGINAL
String string = """
                red
                green
                blue
                """;

// ORIGINAL - after variable declaration changes
static String rgbNames = """
                         red
                         green
                         blue
                         """;

// BETTER
String string = """
    red
    green
    blue
    """;

// BETTER - after variable declaration changes
static String rgbNames = """
    red
    green
    blue
    """;
```

**_G6. Избегайте встроенных текстовых блоков в сложных выражениях, поскольку это может исказить читаемость. Рассмотрите возможность рефакторинга для локальной переменной или статического конечного поля._**
```java
// ORIGINAL
String poem = new String(Files.readAllBytes(Paths.get("jabberwocky.txt")));
String middleVerses = Pattern.compile("\\n\\n")
                             .splitAsStream(poem)
                             .match(verse -> !"""
                                   ’Twas brillig, and the slithy toves
                                   Did gyre and gimble in the wabe;
                                   All mimsy were the borogoves,
                                   And the mome raths outgrabe.
                                   """.equals(verse))
                             .collect(Collectors.joining("\n\n"));

// BETTER
String firstLastVerse = """
    ’Twas brillig, and the slithy toves
    Did gyre and gimble in the wabe;
    All mimsy were the borogoves,
    And the mome raths outgrabe.
    """;
String poem = new String(Files.readAllBytes(Paths.get("jabberwocky.txt")));
String middleVerses = Pattern.compile("\\n\\n")
                             .splitAsStream(poem)
                             .match(verse -> !firstLastVerse.equals(verse))
                             .collect(Collectors.joining("\n\n"));
```

**_G7. Используйте либо только пробелы, либо только табуляцию для отступа текстового блока. Смешивание пробелов приведет к результату с неправильным отступом._**
```java
// ORIGINAL
    String colors = """
········red
␉       green
········blue""";    // result: "·······red\ngreen\n·······blue"

// PROBABLY WHAT WAS INTENDED
    String colors = """
········red
········green
········blue""";    // result: "red\ngreen\nblue"
```

**_G8. Если текстовый блок содержит последовательности из трех или более двойных кавычек, экранируйте первую двойную кавычку каждого цикла из трех двойных кавычек._**
```java
// ORIGINAL
String code = """
    String source = \"\"\"
        String message = "Hello, World!";
        System.out.println(message);
        \"\"\";
    """;

// BETTER
String code = """
    String source = \"""
        String message = "Hello, World!";
        System.out.println(message);
        \""";
    """;
```

**_G9. Большинство текстовых блоков должны иметь отступ для выравнивания с соседним кодом Java._**
```java
    // ORIGINAL - odd indentation
    void printPoem() {
        String poem = """
’Twas brillig, and the slithy toves
Did gyre and gimble in the wabe;
All mimsy were the borogoves,
And the mome raths outgrabe.
""";
        System.out.print(poem);
    }

    // BETTER
    void printPoem() {
        String poem = """
            ’Twas brillig, and the slithy toves
            Did gyre and gimble in the wabe;
            All mimsy were the borogoves,
            And the mome raths outgrabe.
            """;
        System.out.print(poem);
    }
```

**_G10. Рекомендуется полностью выравнивать широкую строку по левому краю, чтобы избежать горизонтальной прокрутки или переноса строк._**
```java
// ORIGINAL

class Outer {
    class Inner {
        void printPoetry() {
            String lilacs = """
                Over the breast of the spring, the land, amid cities,
                Amid lanes and through old woods, where lately the violets peep’d from the ground, spotting the gray debris,
                Amid the grass in the fields each side of the lanes, passing the endless grass,
                Passing the yellow-spear’d wheat, every grain from its shroud in the dark-brown fields uprisen,
                Passing the apple-tree blows of white and pink in the orchards,
                Carrying a corpse to where it shall rest in the grave,
                Night and day journeys a coffin.
                """;
            System.out.println(lilacs);
        }
    }
}

// BETTER

class Outer {
    class Inner {
        void printPoetry() {
            String lilacs = """
Over the breast of the spring, the land, amid cities,
Amid lanes and through old woods, where lately the violets peep’d from the ground, spotting the gray debris,
Amid the grass in the fields each side of the lanes, passing the endless grass,
Passing the yellow-spear’d wheat, every grain from its shroud in the dark-brown fields uprisen,
Passing the apple-tree blows of white and pink in the orchards,
Carrying a corpse to where it shall rest in the grave,
Night and day journeys a coffin.
""";
            System.out.println(lilacs);
        }
    }
}
```

**_G11. Аналогичным образом, также разумно полностью выравнивать текстовый блок по левому краю, когда большое количество строк приводит к тому, что закрывающий разделитель, вероятно, будет прокручиваться по вертикали вне поля зрения. Это позволяет читателю отслеживать отступ с левым полем, когда закрывающий разделитель находится вне поля зрения._**
```java
// ORIGINAL

String validWords = """
                    aa
                    aah
                    aahed
                    aahing
                    aahs
                    aal
                    aalii
                    aaliis
...
                    zythum
                    zythums
                    zyzzyva
                    zyzzyvas
                    zzz
                    zzzs
                    """;


// BETTER

String validWords = """
aa
aah
aahed
aahing
aahs
aal
aalii
aaliis
...
zythum
zythums
zyzzyva
zyzzyvas
zzz
zzzs
""";
```

**_G12. `\<line-terminator>` Управляющую последовательность следует использовать, когда необходимо исключить последнюю новую строку текстового блока. Это лучше обрамляет текстовый блок и позволяет закрывающему разделителю управлять отступом._**
```java
// ORIGINAL

String name = """
    red
    green
    blue""".indent(4);

// BETTER

String name = """
        red
        green
        blue\
    """;
```

### Строковые методы, связанные с текстовыми блоками

Несколько новых методов включены в [String](String) класс как часть функции text blocks .

#### `String formatted(Object... args)`

Этот метод эквивалентен `String.format(this, args)`. Преимущество заключается в том, что в качестве метода экземпляра он может быть привязан к концу текстового блока:
```java
String output = """
    Name: %s
    Phone: %s
    Address: %s
    Salary: $%.2f
    """.formatted(name, phone, address, salary);
```

#### `String stripIndent()`

Метод `stripIndent` удаляет случайные пробелы из многострочной строки, используя тот же алгоритм, который используется компилятором Java. Это полезно, если у вас есть программа, которая считывает текст как входные данные, и вы хотите убрать отступы таким же образом, как это делается для текстовых блоков.

#### `String translateEscapes()`

Этот `translateEscapes` метод выполняет перевод escape-последовательности (`\b`, `\f`, `\n`, `\t`, `\r`, `\"`, `\'`, `\\` и восьмеричные Escape) и используется компилятор Java для обработки текстовых блоков и строковые литералы. Это полезно, если у вас есть программа, считывающая текст в качестве входных данных, и вы хотите выполнить обработку escape-последовательности. Обратите внимание, что экранирование в Юникоде (`\uNNNN`) _не_ обрабатывается.

