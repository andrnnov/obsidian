#Java #Generics 

## Стирание типов

2024-08-01 16:10

Используя Java [Generics](Generics), вы можете писать универсальные программы, и это также обеспечивает более строгую проверку типов во время компиляции, но эти универсальные типы остаются только на уровне исходного кода. При компиляции исходного кода все параметры универсального типа стираются, и этот процесс называется стиранием типов в Java [Generics](Generics).

### Как работает стирание типов

Удаление типов в Java работает следующим образом:
1. Замените все параметры типа в универсальных типах на их связанный тип, если явный связанный тип не указан, тогда замените параметр универсального типа на [Object](Object). Таким образом, созданный байт-код содержит только обычные классы, интерфейсы и методы, при этом все общие параметры заменены реальными типами.
2. При необходимости вставляйте приведения типов для сохранения безопасности типов.
3. Создайте методы моста для сохранения [полиморфизма](https://www.knpcode.com/2020/08/polymorphism-in-java-oops-concepts.html) в расширенных универсальных типах.

### Удаление типа в универсальном классе

Рассмотрим следующий универсальный класс с параметром универсального типа T.
```java
public class GenericClass<T> {
  T obj;
  GenericClass(T obj){
    this.obj = obj;
  }
  public T getObj() {
    return obj;
  } 
}
```
Поскольку параметр типа T не ограничен, компилятор Java заменяет его на Object, и после компиляции класс выглядит следующим образом:
```java
public class GenericClass {
  Object obj;
  GenericClass(Object obj){
    this.obj = obj;
  }
  public Object getObj() {
    return obj;
  } 
}
```

Рассмотрим другой универсальный класс с [параметром ограниченного типа](BorderedGeneric).
```java
public class GenericClass<T extends String> {
  T obj;
  GenericClass(T obj){
    this.obj = obj;
  }
  public T getObj() {
    return obj;
  } 
}
```
Поскольку параметр типа T ограничен, компилятор Java заменяет его связанной класс [String](String), и после компиляции класс выглядит следующим образом:
```java
public class GenericClass {
  String obj;
  GenericClass(String obj){
    this.obj = obj;
  }
  public String getObj() {
    return obj;
  } 
}
```

### Удаление типа в обобщенном методе

Компилятор Java также удаляет параметры типа в аргументах обобщенного метода. Рассмотрим следующий обобщенный метод, который подсчитывает количество вхождений переданного элемента в переданный массив.
```java
public static <T> int count(T[] numberArray, T elem) {
  int cnt = 0;
  for (T e : numberArray){
    if (e.equals(elem))
      ++cnt;
  }
  return cnt;
}
```
Поскольку значение T не ограничено, компилятор Java заменяет его на Object, и скомпилированный метод выглядит следующим образом:
```java
public static int count(Object[] numberArray, Object elem) {
  int cnt = 0;
  for (Object e : numberArray){
    if (e.equals(elem))
      ++cnt;
  }
  return cnt;
}
```

### Стирание типов и мостовые методы

Иногда в рамках процесса стирания типов компилятор создает синтетический метод, называемый мостовым методом. Рассмотрим следующие классы, чтобы увидеть пример мостового метода в Java.
```java
public class GenClass<T> {
  T obj;
  public GenClass(T obj) { 
    this.obj = obj; 
  }
  public void setObj(T obj) {
    this.obj = obj;
  }  
}
```
Затем этот GenClass расширяется другим классом, как указано ниже:
```java
public class MyClass extends GenClass {
  public MyClass(Integer data) { 
    super(data); 
  } 
  public void setObj(Integer data) {
    System.out.println("MyClass.setData");
    super.setObj(data);
  } 
}
```
Здесь предполагается переопределить метод родительского класса setObj() в подклассе. После удаления типа классы GenClass и MyClass становятся:
```java
public class GenClass {
  Object obj;
  public GenClass(Object obj) { 
    this.obj = obj; 
  }
  public void setObj(Object obj) {
    this.obj = obj;
  }  
}
```
```java
public class MyClass extends GenClass {
  public MyClass(Integer data) { 
    super(data); 
  } 
  public void setObj(Integer data) {
    System.out.println("MyClass.setData");
    super.setObj(data);
  } 
}
```
После удаления типа сигнатуры методов не совпадают. Метод GenClass становится setObj (Object obj), а метод MyClass становится setObj (Integer data). Следовательно, метод GenClass setObj не переопределяет метод MyClass setObj.

Чтобы решить эту проблему и сохранить полиморфизм универсальных типов после удаления типов, компилятор Java генерирует метод bridge, гарантирующий, что подтипирование работает должным образом. Для класса MyClass компилятор генерирует следующий метод bridge для setObj():
```java
public class MyClass extends GenClass {
  public MyClass(Integer data) { 
    super(data); 
  } 
  // Bridge method generated by the compiler
  public void setObj(Object data) {
    setObj((Integer) data);
  }
  public void setObj(Integer data) {
    System.out.println("MyClass.setData");
    super.setObj(data);
  } 
}
```
Как вы можете видеть, метод bridge имеет ту же сигнатуру метода, что и метод setObj() GenClass, и он делегирует исходный метод setObj().