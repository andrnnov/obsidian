#Java #Generics #Wildcards

## [Подстановочные знаки](https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html)(Wildcards)

В общем коде знак вопроса (?), называемый _подстановочным знаком_, представляет неизвестный тип. Подстановочный знак может использоваться в различных ситуациях: как тип параметра, поля или локальной переменной; иногда как возвращаемый тип (хотя в практике программирования лучше быть более конкретным). Подстановочный знак никогда не используется в качестве аргумента типа для вызова универсального метода, создания экземпляра универсального класса или супертипа.

### Подстановочные знаки с верхней границей (Upper Bounded Wildcards)

Вы можете использовать подстановочный знак с верхней границей, чтобы ослабить ограничения на переменную. Допустим, вы хотите написать метод, который работает с `List<Integer>`, `List<Double>`, _и_ `List<Number>`; вы можете достичь этого, используя подстановочный знак с верхней границей.

Чтобы объявить подстановочный знак с верхней границей, используйте подстановочный знак ('?'), за которым следует ключевое слово extends, а затем его _верхняя граница_. Обратите внимание, что в данном контексте extends используется в общем смысле и означает либо "extends" (как в классах), либо "implements" (как в интерфейсах).

Чтобы написать метод, который работает со [списками](List) [Number](Number) и подтипами [Number](Number), такими как [Integer](WrapperInteger), Double и Float, вы должны указать `List<? extends Number>`. Термин `List<Number>` является более ограничительным, чем `List<? extends Number>` потому что первый соответствует только списку типа Number, тогда как второй соответствует списку типа Number или любому из его подклассов.

Рассмотрим следующий метод:
```java
public static void process(List<? extends Foo> list) { /* ... */ }
```
Подстановочный знак с верхней границей, `<? extends Foo>`, где Foo - любой тип, соответствует Foo и любому подтипу Foo. Метод `process` может обращаться к элементам списка как к типу Foo:
```java
public static void process(List<? extends Foo> list) {
 for (Foo elem : list) {
 // ...
 }
}
```
В предложении foreach переменная elem выполняет итерацию по каждому элементу в списке. Любой метод, определенный в классе Foo, теперь можно использовать в elem.

Метод sumOfList возвращает сумму чисел в списке:
```java
public static double sumOfList(List<? extends Number> list) {
	double s = 0.0;
	for (Number n : list)
		s += n.doubleValue();
	return s;
}
```
Следующий код, использующий список объектов Integer, выводит sum = 6.0:
```java
List<Integer> li = Arrays.asList(1, 2, 3);
System.out.println("sum = " + sumOfList(li));
```
Список значений Double может использовать один и тот же метод sumOfList. Следующий код выводит sum = 7.0:
```java
List<Double> ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println("sum = " + sumOfList(ld));
```

### Неограниченные подстановочные знаки (Unbounded Wildcards)

Тип неограниченного подстановочного знака задается с помощью подстановочного знака (?), например, `List<?>`. Это называется _список неизвестного типа_. Есть два сценария, в которых неограниченный подстановочный знак является полезным подходом:

- Если вы пишете метод, который может быть реализован с использованием функциональности, предоставленной в классе [Object](Object).
- Когда в коде используются методы универсального класса, которые не зависят от параметра type. Например, List.size или List.clear. На самом деле, `Class<?>` так часто используется потому, что большинство методов в `Class<T>` не зависят от T.

Рассмотрим следующий метод:
```java
public static void printList(List<Object> list) {
    for (Object elem : list)
        System.out.println(elem + " ");
    System.out.println();
}
```
Целью printList является печать списка любого типа, но ему не удается достичь этой цели — он печатает только список экземпляров [Object](Object); он не может печатать `List<Integer>`, `List<String>`, `List<Double>` и так далее, потому что они не являются подтипами `List<Object>`. Чтобы написать универсальный метод printList, используйте `List<?>`:
```java
public static void printList(List<?> list) {
    for (Object elem: list)
        System.out.print(elem + " ");
    System.out.println();
}
```
Поскольку для любого конкретного типа A, `List<A>` является подтипом `List<?>`, вы можете использовать printList для печати списка любого типа:
```java
List<Integer> li = Arrays.asList(1, 2, 3);
List<String>  ls = Arrays.asList("one", "two", "three");
printList(li);
printList(ls);
```
Важно отметить, что `List<Object>` и `List<?>` - это не одно и то же. Вы можете вставить Object или любой подтип Object в `List<Object>`. Но вы можете вставить только null в `List<?>`.

### Подстановочные знаки с нижним ограничением (Lower Bounded Wildcards)

В разделе "Подстановочные знаки с верхним ограничением" показано, что подстановочный знак с верхним ограничением ограничивает неизвестный тип определенным типом или подтипом этого типа и представлен с помощью ключевого слова extends. Аналогичным образом, подстановочный знак с нижним ограничением ограничивает неизвестный тип определенным типом или супертипом этого типа.

Подстановочный знак с нижним ограничением выражается с помощью символа подстановки ('?'), за которым следует ключевое слово super и его нижняя граница: `<? super A>`.

>**Примечание:** Вы можете указать верхнюю границу для подстановочного знака или нижнюю границу, но вы не можете указать оба варианта.

Допустим, вы хотите написать метод, который помещает Integer в список. Для максимальной гибкости вам бы хотелось, чтобы метод работал с `List<Integer>`, `List<Number>` и `List<Object>` — со всем, что может содержать Integer значения.

Чтобы написать метод, который работает со списками Integer и супертипами Integer, такими как [Integer](WrapperInteger), [Number](Number) и [Object](Object), вы должны указать `List<? super Integer>`. Термин `List<Integer>` является более ограничительным, чем `List<? super Integer>` потому что первое соответствует списку только типа Integer, тогда как второе соответствует списку любого типа, который является супертипом Integer.

Следующий код добавляет числа с 1 по 10 в конец списка:
```java
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}
```

### Подстановочные знаки и подтипы (Wildcards and Subtyping)

Общие классы или интерфейсы не связаны между собой только потому, что между их типами существует взаимосвязь. Однако вы можете использовать подстановочные знаки для создания связи между универсальными классами или интерфейсами.

Приведены следующие два обычных (не общих) класса:
```java
class A { /* ... */ }
class B extends A { /* ... */ }
```
Было бы разумно написать следующий код:
```java
B b = new B();
A a = b;
```
Этот пример показывает, что наследование обычных классов следует этому правилу подтипов: класс B является подтипом класса A, если B расширяет A. Это правило не применяется к универсальным типам:
```java
List<B> lb = new ArrayList<>();
List<A> la = lb;   // compile-time error
```
Учитывая, что [Integer](WrapperInteger) является подтипом [Number](Number), какова связь между `List<Integer >` и `List<Number>`?

Хотя Integer является подтипом Number, `List<Integer>` не является подтипом `List<Number>` и, фактически, эти два типа не связаны. Общим родительским элементом `List<Number>` и `List<Integer>` является `List<?>`.

Чтобы создать связь между этими классами, чтобы код мог обращаться к методам Number через элементы `List<Integer>`, используйте подстановочный знак, ограниченный верхним знаком:
```java
List<? extends Integer> intList = new ArrayList<>();
List<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>
```
Поскольку Integer является подтипом Number, а numList - это список объектов Number, теперь существует связь между IntList (списком объектов Integer) и numList. На следующей диаграмме показаны взаимосвязи между несколькими классами [List](List), объявленными как с верхними, так и с нижними подстановочными знаками.
![[generics-wildcardSubtyping.gif]]

### Рекомендации по использованию подстановочных знаков

Одним из наиболее запутанных аспектов при обучении программированию с использованием generics является определение того, когда использовать подстановочный знак с верхней границей, а когда с нижней. На этой странице приведены некоторые рекомендации, которым следует следовать при разработке вашего кода.

Для целей данного обсуждения полезно рассматривать переменные как обеспечивающие одну из двух функций:

**Переменная "In"**

Переменная "in" передает данные в код. Представьте метод копирования с двумя аргументами: copy(src, dest). Аргумент src предоставляет данные для копирования, поэтому это параметр "in".

**Переменная "Out"**

Переменная "out" содержит данные для использования в другом месте. В примере копирования, copy(src, dest), аргумент dest принимает данные, поэтому это параметр "out".

Конечно, некоторые переменные используются как для целей "in", так и "out" - этот сценарий также рассматривается в рекомендациях.

Вы можете использовать принцип "in" и "out" при принятии решения о том, использовать ли подстановочный знак и какой тип подстановочного знака подходит. В следующем списке приведены рекомендации, которым следует следовать.

**Рекомендации по подстановочным знакам:** 

- Переменная "in" определяется подстановочным знаком, ограниченным сверху, с использованием ключевого слова extends.
- Переменная "out" определяется с помощью подстановочного знака, ограниченного нижним пределом, с использованием ключевого слова super.
- В случае, когда к переменной "in" можно получить доступ с помощью методов, определенных в классе [Object](Object), используйте неограниченный подстановочный знак.
- В случае, когда коду необходимо обращаться к переменной как к переменной "in", так и к переменной "out", не используйте подстановочный знак.

Эти рекомендации не распространяются на возвращаемый тип метода. Следует избегать использования подстановочных знаков в качестве возвращаемого типа, поскольку это вынуждает программистов, использующих код, иметь дело с подстановочными знаками.

Список, определенный с помощью `List<? extends ...>` неофициально можно рассматривать как доступный только для чтения, но это не является строгой гарантией. Предположим, у вас есть следующие два класса:
```java
class NaturalNumber {

    private int i;

    public NaturalNumber(int i) { this.i = i; }
    // ...
}

class EvenNumber extends NaturalNumber {

    public EvenNumber(int i) { super(i); }
    // ...
}
```
Рассмотрим следующий код:
```java
List<EvenNumber> le = new ArrayList<>();
List<? extends NaturalNumber> ln = le;
ln.add(new NaturalNumber(35));  // compile-time error
```

Потому что `List<EvenNumber>` является подтипом `List<? extends NaturalNumber>`, вы можете присвоить le ln. Но вы не можете использовать ln для добавления натурального числа к списку четных чисел. Возможны следующие операции над списком:
- Вы можете добавить null.
- Вы можете вызвать clear.
- Вы можете получить итератор и вызвать remove.
- Вы можете использовать подстановочный знак и записывать элементы, которые вы прочитали из списка.

Вы можете видеть, что список, определенный с помощью `List<? extends NaturalNumber>` не доступен только для чтения в строгом смысле этого слова, но вы можете думать об этом именно так, потому что вы не можете сохранить новый элемент или изменить существующий элемент в списке.