#### Класс Integer ####

#Java #Wrapper #Integer

Класс [Integer — это класс-обертка](WrapperClasses) примитивного типа int. Внутри данного класса содержится единственное поле типа int. Будучи классом оберткой, Integer предоставляет различные методы для работы с int, а также ряд методов для преобразования int в String и String в int. Ниже мы рассмотрим различные примеры работы с классом. Начнем с создания. Чаще всего используется (да и проще всего использовать) следующий вариант создания:
```java
Integer a = 3;
```
То есть инициализация Integer переменной в данном случае аналогична инициализации int переменной. Более того, Integer переменную можно проинициализировать значением int переменной:
```java
int i = 5;
Integer x = i;
System.out.println(x); // 5
```
Помимо вариантов инициализации, указанных выше, переменную Integer можно создать, как и прочие объекты, с использованием конструктора и ключевого слова new:
```java
Integer x = new Integer(25);
System.out.println(x);
```
Однако так дольше писать и дольше читать, поэтому данный вариант наименее распространен. С Integer переменными можно делать все то, что и с int переменными. Их можно:

|   |   |
|---|---|
|Складывать|```<br><br>Integer a = 6;<br>Integer b = 2;<br>Integer c = a + b;<br>System.out.println(c); // 8<br>```|
|Вычитать|```<br><br>Integer a = 6;<br>Integer b = 2;<br>Integer c = a - b;<br>System.out.println(c); // 4<br>```|
|Умножать|```<br><br>Integer a = 6;<br>Integer b = 2;<br>Integer c = a * b;<br>System.out.println(c); // 12<br>```|
|Делить|```<br><br>Integer a = 6;<br>Integer b = 2;<br>Integer c = a / b;<br>System.out.println(c); // 3<br>```|
|Инкрементировать|```<br><br>Integer a = 6;<br>a++;<br>++a;<br>System.out.println(a); // 8<br>```|
|Декрементировать|```<br><br>Integer a = 6;<br>a--;<br>--a;<br>System.out.println(a); // 4<br>```|

Однако при всем этом нужно быть осторожным и помнить, что Integer — это ссылочный тип данных, и переменная данного типа может быть null. В таком случае (если переменная равна null) лучше воздержаться от арифметических операций (да и любых других, в которых null ничего хорошего не сулит). Приведем пример:
```java
Integer a = null;
Integer b = a + 1; // Здесь мы упадем с "Exception in thread "main" 
				   //java.lang.NullPointerException"
System.out.println(b);
```
Операции сравнения в основной массе проводятся также, как и в примитивном типе int:
```java
Integer a = 1;
Integer b = 2;

System.out.println(a > b);
System.out.println(a >= b);
System.out.println(a < b);
System.out.println(a <= b);
```
Вывод:
==false
false
true
true==

Особняком стоит операция сравнения двух Integer переменных. И дело тут в том, что Integer — это ссылочный тип данных, и его переменные хранят ссылки на значения, а не сами значения (объекты). Проявления этого факта можно наблюдать при выполнении следующего фрагмента кода:
```java
Integer a = 1;
Integer b = 1;
Integer c = new Integer(1);

System.out.println(a == b); // true
System.out.println(a == c); // false
```
Результат первого равенства будет true, а второго — false. Так происходит, потому что в первом случае мы сравниваем две переменные (“а” и “b”), которые хранят в себе ссылки на один и тот же объект. А во втором случае мы сравниваем две переменные, ссылающиеся на два разных объекта (при создании переменной “c” мы создали новый объект).
Приведем еще 1 интересный пример:
```java
Integer a = 1;
Integer b = 1;

Integer x = 2020;
Integer y = 2020;

System.out.println(a == b); // true
System.out.println(x == y); // false
```
Как мы видим, результат первого сравнения у нас true, а результат второго — false. Тут все дело в кэшировании. Все целые числа в промежутке от -128 до 127 включительно (данные значения можно кастомизировать) кэшируются. Поэтому когда мы создаем новую переменную и присваиваем ей целочисленное значение, лежащее в промежутке от -128 до 127, мы не создаем новый объект, а присваиваем переменной ссылку на уже созданный объект в кэше. Теперь, зная этот факт, пример выше не кажется таким уж мистическим. Переменные а и b ссылаются на один и тот же объект — объект из кэша. А во время инициализации переменных x и y мы каждый раз создавали новый объект, и данные переменные хранили в себе ссылки на разные объекты. А как известно, оператор == сравнивает значения переменных, а значением ссылочных переменных являются ссылки. Чтобы безошибочно проверять на равенство две Integer переменные, необходимо использовать (как бы банально это ни звучало) метод equals. Перепишем пример выше:
```java
Integer a = 1;
Integer b = 1;

Integer x = 2020;
Integer y = 2020;

System.out.println(a.equals(b)); // true
System.out.println(x.equals(y)); // true
```
#### Автоупаковка и распаковка Integer ####

Что такое автоупаковка и распаковка? При создании новых Integer переменных мы использовали такую конструкцию:
```java
Integer a = 2020;
```
Таким образом мы создавали новый объект без использования ключевого оператора new. Такое возможно благодаря механизму автоупаковки примитивного типа int. Обратная процедура проявляется при присваивании примитивной переменной int значения ссылочной Integer переменной:
```java
Integer a = 2020;
int x = a;
```
В данном случае мы вроде бы присвоили ссылку (а именно — ссылка на объект является значением переменной “а”) примитивной переменной. Но по факту благодаря механизму автораспаковки в переменную “х” записалось значение 2020. Автоупаковка/распаковка — весьма распространенное явление в Java. Часто оно происходит само собой, иногда даже без ведома программиста. Но знать об этом явлении все же нужно.
#### Константы класса Integer ####

Класс Integer предоставляет различные константы и методы для работы с целыми числами. В данном разделе мы более подробно рассмотрим некоторые из них на практике. Начнем с констант. В таблице ниже приведены все константы класса:

|Костанта|Описание|
|---|---|
|SIZE|Количество битов в двузначной системе счисления, занимаемое типом int|
|BYTES|Количество байтов в двузначной системе счисления, занимаемое типом int|
|MAX_VALUE|Максимальное значение, которое вмещает в себя тип int|
|MIN_VALUE|Минимальное значение, которое вмещает в себя тип int|
|TYPE|Возвращает объект типа Class от типа int|

Посмотрим на значения всех этих констант, выполнив следующий код:
```java
public static void main(String[] args) {
        System.out.println(Integer.SIZE);
        System.out.println(Integer.BYTES);
        System.out.println(Integer.MAX_VALUE);
        System.out.println(Integer.MIN_VALUE);
        System.out.println(Integer.TYPE);
}
```
В результате получим следующий вывод:
==32
4
2147483647
-2147483648
int==
#### Методы класса Integer ####

А теперь кратко рассмотрим наиболее используемые методы класса Integer. Итак, “топ” возглавляют методы по преобразованию числа из строки, либо преобразованию строки из числа. Начнем с преобразований строки в число. Для этих целей служит метод **parseInt**, сигнатура ниже:
```java
static int parseInt(String s)
```
Данный метод преобразует String в int. Продемонстрируем работу данного метода:
```java
int i = Integer.parseInt("10");
System.out.println(i); // 10
```
Если преобразование невозможно — например, мы передали слово в метод parseInt — будет брошено исключение NumberFormatException. У метода parseInt(String s) есть перегруженный собрат:
```java
static int parseInt(String s, int radix)
```
Данный метод преобразует параметр s в int. В параметре radix указывается, в какой системе счисления изначально записано число в s, которое необходимо преобразовать в int. Примеры ниже:
```java
System.out.println(Integer.parseInt("0011", 2)); // 3
System.out.println(Integer.parseInt("10", 8));   // 8
System.out.println(Integer.parseInt("F", 16));   // 15
```
Методы parseInt возвращают примитивный тип данных int. У данных методов есть аналог — метод **valueOf**. Некоторые вариации данного метода внутри себя просто вызывают parseInt. Отличие от parseInt в том, что результатом работы valueOf будет Integer, а не int. Рассмотрим ниже все варианты данного метода и пример его работы:
- static Integer valueOf(int i) — возвращает Integer значением которого является i;
- static Integer valueOf(String s) — аналогичен parseInt(String s), но результатом будет Integer;
- static Integer valueOf(String s, int radix) — аналогичен parseInt(String s, int radix), но результатом будет Integer.
Примеры:
```java
int a = 5;
Integer x = Integer.valueOf(a);
Integer y = Integer.valueOf("20");
Integer z = Integer.valueOf("20", 8);

System.out.println(x); // 5
System.out.println(y); // 20
System.out.println(z); // 16
```
Мы рассмотрели методы, позволяющие перевести String в int/Integer. Обратная процедура достигается с помощью методов **toString**. У любого Integer объекта можно вызвать метод toString и получить его строковое представление:
```java
Integer x = 5;
System.out.println(x.toString()); // 5
```
Однако в связи с тем, что метод toString часто вызывается у объектов неявно (например, при передаче объекта на печать в консоль), данный метод редко используется разработчиками в явном виде. Есть также и статический метод toString, который принимает в себя int параметр и переводит его в строковое представление. Например:
```java
System.out.println(Integer.toString(5)); // 5
```
Однако, как и не статический метод toString, использование статического в явном виде можно встретить редко. Более интересен статический метод toString, который принимает 2 целочисленных параметра:
- static String toString(int i, int radix) — переведет i в строковое представление в системе счисления radix.
Пример:
```java
System.out.println(Integer.toString(5, 2)); // 101
```
В классе Integer есть пару методов для нахождения максимума/минимума из двух чисел:
- static int max(int a, int b) вернет наибольшее из значений среди переданных переменных;
- static int min(int a, int b) вернет наименьшее из значений среди переданных переменных.
Примеры:
```java
int x = 4;
int y = 40;

System.out.println(Integer.max(x,y)); // 40
System.out.println(Integer.min(x,y)); // 4
```