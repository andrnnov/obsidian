#java #StreamAPI 
### Метод collect ###

2023-12-18 15:20

Большинство операций класса [Stream](StreamAPI), которые модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции, например, [`List<T>`](List), [`Set<T>`](Set), [`Map<T, R>`](Map) и другим. И для этого у класса Stream определен метод collect. В метод `collect()` нужно передать специальный объект — `collector`. Этот объект вычитывает все данные из потока, преобразует их к определенной коллекции и возвращает ее. А следом за ним эту же коллекцию возвращает и сам метод collect.

Объект `collector` имеет тип `Collector<T, A, R>` – у него три типа-параметра. Последний тип `R` — это обычно и есть тип вроде `List<T>`. Поэтому компилятор может по этому типу подставить правильный тип результата самого метода `collect()`.

#### Класс Collectors ####

У класса `Collectors` есть несколько статических методов, которые возвращают готовые объекты-коллекторы на все случаи жизни. Их несколько десятков, но мы рассмотрим самые основные:

|                                             |                                                           |
| ------------------------------------------- | --------------------------------------------------------- |
| toList()                                    | Объект, который преобразует поток в список — `List<T>`    |
| toSet()                                     | Объект, который преобразует поток во множество — `Set<T>` |
| toMap()                                     | Объект, который преобразует поток в мэп — `Map<K, V>`     |
| joining()                                   | Склеивает элементы потока в одну строку                   |
| [[GroupingStream#Метод mapping\|mapping()]] | Преобразует элементы потока в `Map<K, V>`                 |
| groupingBy()                                | Группирует элементы, возвращает `Map <K, V>`              |

#### Преобразование потока в [список](List) ####

Вот как выглядит типичная работа с потоком и преобразование результата работы в список
```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "Привет", "как", "дела?");

List<String> result = list.stream()
   .filter( s -> Character.isUpperCase(s.charAt(0)) )
   .collect( Collectors.toList() );
```
Мы получили поток у коллекции, затем у него получили новый поток, отфильтровав только строки, первый символ которых — заглавный. Затем все данные из последнего потока собрали в коллекцию и вернули ее.
#### Преобразование потока во [множество](Set) ####

Вот как выглядит типичная работа с потоком и преобразование результата работы во множество
```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "Привет", "как", "дела?");

Set<String> result = list.stream()
   .filter( s -> Character.isUpperCase(s.charAt(0)) )
   .collect( Collectors.toSet() );
```
Все очень похоже на код по преобразованию потока в `List`, только используется другой объект-коллектор, который возвращает метод `toSet();`
## Преобразование потока в [мэп](Map)

А вот преобразовать поток в мэп немного сложнее. Ведь каждый объект Map состоит из двух элементов — ключа и значения. Нам нужно придумать, как у элемента потока мы будем определять ключ, а как — значение.

Пример.
```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "a=2", "b=3", "c=4", "d==3");

Map<String, String> result = list.stream()
   .map( e -> e.split("=") )
   .filter( e -> e.length == 2 )
   .collect( Collectors.toMap(e -> e[0], e -> e[1]) );
```
В первой строчке `map(...)` мы преобразовываем каждую строку в массив строк. Используя метод split, мы делим каждую строку на две части по символу «равно».

Во второй строке — метод `filter()` — мы пропускаем через фильтр только те элементы-массивы, которые содержат ровно два элемента. Элемент `d == 3` был разбит на массив из трех элементов, и фильтр не пройдет.

И наконец, в последней строке мы превращаем поток в `Map<String, String>`. В метод `toMap()` передаются две функции. Для каждого элемента потока первая функция должна вернуть ключ, а вторая — значение.

У нас в качестве ключа будет первый элемент массива ("a", "b", "c"), а в качестве значений — второй элемент массива: "2", "3", "4".
#### Преобразование потока в [строку](String) ####

Еще один интересный объект-коллектор — это `Collectors.joining()`. Он преобразовывает все элементы потока к типу [`String`](String) и склеивает их в одну строку. Пример
```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "a=2", "b=3", "c=4", "d==3");
String result = list.stream().collect( Collectors.joining(", ") );
```
