#Java #sealed #non-sealed #permit

## Запечатанные (sealed) классы в Java

2024-07-25 14:50

Запечатанные классы впервые появились в Java 15 в качестве функции предварительного просмотра, а затем и в Java 16, в том же самом статусе. Полноценной эта функция стала с выходом Java 17 (JEP 409).

### Что такое запечатанные классы?

Запечатанный (**_sealed_**) класс позволяет ограничивать или выбирать подклассы. Класс не может расширять закрытый класс, если его нет в списке разрешенных дочерних классов родительского класса.

Класс запечатывается с использованием ключевого слова **_sealed_**. За запечатанным классом должно следовать ключевое слово permits вместе со списком классов, которые могут его расширить. Вот пример:
```java
public sealed class Device permits Computer, Mobile {}
```
Эта декларация означает, что Device может быть расширен только классами Computer и Mobile. Если какой-либо другой класс попытается его расширить, то появится ошибка компилятора.

Класс, который расширяет запечатанный класс, должен иметь в своей декларации ключевое слово final, **_sealed_** или **_non-sealed_**. Таким образом у нас есть фиксированная иерархия классов.

Как это связано с созданием дочернего класса?
1. final означает, что он не может быть далее подклассифицирован.
2. sealed означает, что нам нужно объявить дочерние классы с permits.
3. non-sealed означает, что здесь мы заканчиваем иерархию parent-child (родительский-дочерний).

К примеру, Computer разрешает (permits) классы Laptop и Desktop, пока Laptop сам остается non-sealed. Это означает, что Laptop может быть расширен такими классами, как Apple, Dell, HP и так далее.

#### Основные цели введения запечатанных классов:

1. До сих пор вы могли ограничить расширение класса только с помощью ключевого слова final. Запечатанный класс контролирует, какие классы могут его расширять, включая их в разрешенный список.
2. Также это позволяет классу контролировать, какие из них будут его дочерними классами.

### Правила

Несколько правил, которые нужно помнить при использовании запечатанных классов:
1. Запечатанный класс должен определять классы, которые могут расширять его с помощью permits. Этого не требуется, если дочерние классы определены внутри родительского класса как внутренний класс.
2. Дочерний класс должен быть либо final, sealed либо non-sealed.
3. Разрешенный дочерний класс (permitted child class) должен расширять родительский запечатанный класс.  То есть если запечатанный класс A допускает класс B, то B должен расширить A.
4. Если запечатанный класс находится в модуле, то дочерние классы также должны быть в том же модуле или в том же пакете, если родительский запечатанный класс находится в безымянном модуле.
5. Только непосредственно разрешенные классы (directly permitted classes) могут расширять запечатанный класс. То есть, если A является запечатанным классом, который позволяет B расширять его, то B также является запечатанным классом, который разрешает C. Тогда C может только расширять B, но не может напрямую расширять A. Тогда C может только расширять B, но не может напрямую расширять A.

### Запечатанные интерфейсы

Подобно запечатанным классам, интерфейсы также могут быть запечатаны. Такой интерфейс может позволить выбирать свои дочерние интерфейсы или классы, которые могут расширять его с помощью permits.

Вот наглядный пример:
```java
public sealed interface Device permits Electronic, Physical, DeviceImpl {}
```
Здесь интерфейс Device позволяет интерфейсам Electronic и Physical расширять его и класс DeviceImpl для последующей реализации.

### Запечатанные записи (Record)

[Запечатанные классы (Record)](Record) можно использовать с записями, представленными в Java 16. Запись не может расширять обычный класс, поэтому она может реализовать только закрытый интерфейс.

Кроме того, запись подразумевает наличие final.

Таким образом, запись не может использовать ключевое слово permits, поскольку ее нельзя разделить на подклассы. То есть, существует лишь одноуровневая иерархия с записями. Вот пример:
```java
public sealed interface Device permits Laptop {
}
public record Laptop(String brand) implement Device {
}
```

### Поддержка Reflection

Java [Reflection](Reflection) обеспечивает поддержку запечатанных классов. Следующие два метода были добавлены в java.lang.Class:

#### 1. getPermittedSubclasses()

Здесь возвращается массив java.lang.Class, содержащий все классы, разрешенные этим объектом класса. Пример:
```java
Device c = new Device();
Class<? extends Device> cz = c.getClass();
Class<?>[] permittedSubclasses = cz.getPermittedSubclasses();
for (Class<?> sc : permittedSubclasses){
  System.out.println(sc.getName());
}
```
**Вывод:**
<p style="background-color: navy; color: yellow">
Computer<br>
Mobile</p>

#### 2. isSealed()
Здесь возвращается true, если класс или интерфейс, в котором он вызывается, запечатан.
