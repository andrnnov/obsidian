#Java #switch

### Полное руководство по switch в Java

2024-01-24 11:08

Старый добрый _switch_ был в Java с первого дня. Мы все используем его и привыкли к нему — особенно к его причудам (кого-нибудь еще раздражает _break_?). Но начиная с [Java 12](https://openjdk.org/jeps/325), ситуация начала меняться: _switch_ вместо оператора стал выражением:
```java
boolean result = switch (ternaryBool) {
    case TRUE -> true;
    case FALSE -> false;
    case FILE_NOT_FOUND -> throw new UncheckedIOException(
            "This is ridiculous!",
            new FileNotFoundException());
    default -> throw new IllegalArgumentException("Seriously?!");
};
```
Результат работы switch-выражения теперь можно сохранять в переменную; ушла необходимость использовать _break_ в каждой ветке _case_ благодаря лямбда-синтаксису и многое другое.  

Когда дело доходит до _switch_ после Java 14, необходимо выбрать стиль его использования:  
- оператор или выражение (с Java 14)
- двоеточия или стрелки (с Java 14)
- метки или шаблоны (3-й превью в Java 19)

#### Недостатки оператора switch

Прежде, чем перейти к обзору нововведений, давайте рассмотрим один пример кода. Допустим, мы столкнулись с «ужасным» тернарным _boolean_ и хотим преобразовать его в обычный _boolean_. Вот один из способов сделать это:
```java
// Тернарный boolean
enum Bool { 
    TRUE, 
    FALSE, 
    FILE_NOT_FOUND
};
```
```java
boolean result;
switch (ternaryBool) {
    case TRUE:
        result = true;
        break;
    case FALSE:
        result = false;
        break;
    case FILE_NOT_FOUND:
        // объявление переменной для демонстрации проблемы в default
        var ex = new UncheckedIOException("This is ridiculous!",
                new FileNotFoundException());
        throw ex;
    default:
        // А вот и проблема: мы не можем объявить еще одну переменную с именем ex
        var ex2 = new IllegalArgumentException("Seriously?!");
        throw ex2;
}
```
Реализация данного кода хромает:  
- наличие _break_ в каждой ветке, которые легко забыть
- можно не учесть все возможные значения _ternaryBool_ (забыть реализовать какой-то _case_)
- с переменной _result_ не все гладко — область видимости не соответствует ее использованию
- нельзя объявить в разных ветках переменные с одинаковым именем

Согласитесь, что данное решение выглядит крайне громоздко и неудобно — тут явно есть что улучшить.

А вот пример попроще, демонстрирующий похожие проблемы:
```java
int result;
switch (number) {
    case 1:
        result = callMethod("one");
        break;
    case 2:
        result = callMethod("two");
        break;
    default:
        result = callMethod("many");
        break;
}
```
Давайте попробуем устранить все недостатки, поместив _switch_ в отдельный метод:
```java
private static boolean toBoolean(Bool ternaryBool) {
    switch (ternaryBool) {
        case TRUE: return true;
        case FALSE: return false;
        case FILE_NOT_FOUND:
            throw new UncheckedIOException("This is ridiculous!",
                    new FileNotFoundException());
        // без default метод не скомпилируется
        default:
            throw new IllegalArgumentException("Seriously?!");
      }
}
```
Так намного лучше: отсутствует фиктивная переменная _result_, нет _break_, загромождающих код и сообщений компилятора об отсутствии _default_ (даже если в этом нет необходимости, как в данном случае).  

Но если подумать, то мы не обязаны создавать методы только для того, чтобы обойти неуклюжую особенность языка. И это даже без учёта, что такой рефакторинг не всегда возможен. Нет, нам нужно решение получше!

#### Представляем switch-выражения

Начиная с Java 12 и выше, вы можете решить вышеуказанные проблемы следующим образом:
```java
boolean result = switch (ternaryBool) {
    case TRUE -> true;
    case FALSE -> false;
    case FILE_NOT_FOUND -> throw new UncheckedIOException(
            "This is ridiculous!",
            new FileNotFoundException());
    // в ветке `default` уже нет необходимости
    default -> throw new IllegalArgumentException("Seriously?!");
};
```
Я думаю, что это довольно очевидно: если _ternartBool_ равен _TRUE_, то _result_ будет присвоено _true, а_ _FALSE_ становится _false_.  

Сразу возникают две мысли:  
- _switch_ теперь может иметь результат
- какие возможности предоставляют стрелки?

Прежде чем углубляться в детали новых возможностей, вначале я расскажу об этих двух аспектах.

#### Выражение vs оператора

Возможно, вы удивлены, что _switch_ теперь является выражением. А чем же он был до этого? До Java 12 _switch_ был оператором — императивной конструкцией, управляющей исполняющим потоком.  

Думайте о различиях старой и новой версии _switch_, как о разнице между _if_ и _тернарным оператором_. Они оба проверяют логическое условие и выполняют ту или иную ветку в зависимости от его результата.  

Разница состоит в том, что _if_ просто выполняет соответствующий блок, тогда как _тернарный оператор_ возвращает какой-то результат:
```java
if (condition) {
    result = doThis();
} else {
    result = doThat();
}

result = condition ? doThis() : doThat();
```
То же самое и у _switch_: до Java 12, если вы хотели вычислить значение и сохранить результат, то должны были либо присвоить его переменной, либо вернуть из метода, созданного специально для оператора _switch_.  

Теперь же результат вычислений оператора _switch_ может быть присвоен переменной.  

Еще одно отличие заключается в том, что поскольку выражение является частью оператора, то оно должно заканчиваться точкой с запятой, в отличие от классического оператора _switch_.

#### Стрелка vs двоеточия

В самом начале статьи использовался пример с новым синтаксисом в лямбда-стиле со стрелкой между меткой и выполняющейся частью. Эквивалентный ему код без лямбда-стиля можно записать так:  
```java
boolean result = switch (ternaryBool) {
    case TRUE:
        yield true;
    case FALSE:
        yield false;
    case FILE_NOT_FOUND:
        throw new UncheckedIOException(
                "This is ridiculous!",
                new FileNotFoundException());
    default:
        throw new IllegalArgumentException("Seriously?!");
};
```
Обратите внимание, что вам нужно использовать новое ключевое слово _yield_, чтобы вернуть значение из ветки _case_ (этот синтаксис появился в Java 13. В Java 12 вместо _yield_ применялся _break_, т. е. _break true_ вместо _yield true,_ что выглядело странно).

Исторически сложилось, что метки с двоеточием определяют точку входа в блок операторов. С этого места начинается выполнение всего кода ниже, даже когда встречается другая метка (при отсутствии _break_). Механизм такой работы известен, как сквозной переход к следующему _case_. Для его прерывания нужен _break_ или _return_.  

Использование же стрелки позволяет выполнять только блок справа от нее. И никакого «проваливания».

#### Подробнее об эволюции switch

##### Несколько меток на case

Отсутствие _break_ в _case_ часто используется для применения одинакового поведение к веткам с разными метками. При этом программа будет переходить к следующему _case_, пока не наткнется на _break._ Из этого можно сделать вывод, что оператор _switch_ в каждом _case_ поддерживает наличие только одной метки:
```java
switch (number) {
    case 1:
    case 2:
        callMethod("few");
        break;
    default:
        callMethod("many");
        break;
}
```
А в новом _switch_ один _case_ может соответствовать нескольким меткам:
```java
String result = switch (ternaryBool) {
    case TRUE, FALSE -> "sane";
    default -> "insane";
};
```
Поведение этого кода очевидно: _TRUE_ и _FALSE_ приводят к одному и тому же результату — вычисляется выражение "sane".

##### Поддержка других типов помимо Enum

Все примеры в этом посте в основном ориентированы на использование _Enum_. А как насчет других типов? На данный момент нет ни каких изменений: _switch_ может работать с _String, int, short, byte, char_ и их обертками. Хотя стоит отметить, что использование _float, double_ и _long_ находится на рассмотрении.

#### Подробнее о стрелке

Начиная с Java 14, _switch_ позволяет использовать лямбда-стрелку для "сопоставления" _case_ с кодом:
```java
switch (number) {
    case 1 -> callMethod("one");
    case 2 -> callMethod("two");
    default -> callMethod("many");
}
```
Давайте рассмотрим два свойства, характерных для стрелочной формы записи разделителя:  
- отсутствие сквозного перехода к следующему _case_  
- блоки операторов

##### Отсутствие перехода к следующему case

Вот, что говорится в [JEP 325](https://openjdk.org/jeps/325) об этом:  
>«…Текущий дизайн оператора _switch_ в Java тесно связан с такими языками, как C и C++ и по умолчанию поддерживает сквозную семантику. Хотя этот традиционный способ управления часто полезен для написания низкоуровневого кода (такого как парсеры для двоичного кодирования), но поскольку _switch_ используется и в коде более высокого уровня, ошибки такого подхода начинают перевешивать его гибкость.»

Я полностью согласен и приветствую возможность использовать _switch_ без поведения по умолчанию:
```java
switch (ternaryBool) {
    case TRUE, FALSE -> System.out.println("Bool was sane");
    default -> System.out.println("Bool was insane");
};
```
Стрелка позволяет вывести _"__Bool was sane"_ в единственном экземпляре, в то время, как с двоеточием это же сообщение отобразилось бы дважды.

##### Блоки операторов

Как и в случае с [лямбдами](Lambda), стрелка может указывать либо на один оператор (как выше), либо на блок, **выделенный фигурными скобками**:
```java
boolean result = switch (Bool.random()) {
    case TRUE -> {
        System.out.println("Bool true");
        yield true;
    }
    case FALSE -> {
        System.out.println("Bool false");
        yield false;
    }
    case FILE_NOT_FOUND -> {
        var ex = new UncheckedIOException(
                "This is ridiculous!",
                new FileNotFoundException());
                throw ex;
    }
    default -> {
        var ex = new IllegalArgumentException(
                "Seriously?!");
                throw ex;
    }
};
```
**Блоки необходимы для использования более одной строки кода в _case_.** При этом они имеют дополнительное преимущество — позволяют создавать одинаковые имена переменных в разных ветках за счет локальной области видимости для каждой ветки.  

>Если вам показался необычным способ выхода из блоков с помощью _yield_, а не _return_, то это необходимо, чтобы избежать путаницы, _return_ может быть неправильно истолкован, как выход из метода. Мы лишь завершаем работу _switch_, оставаясь в том же методе.

#### Подробнее о выражениях switch 

Рассмотрим особенности использования _switch_ в качестве выражения:  
- множественные выражения  
- ранний возврат  
- охват всех значений (исчерпываемость)

##### Множественные выражения

Switch-выражения являются множественными выражениями. Это означает, что они не имеют своего собственного типа, но могут быть одним из нескольких типов. Наиболее часто в качестве таких выражений используются [лямбда-выражения](Lambda): `s -> s + " "`, могут быть и `Function<String, String>`, и `Function<Serializable, Object>` или `UnaryOperator<String>`.  

Тип switch-выражения определяется исходя из типов его веток, а также из места его использования. Если результат работы switch-выражения присваивается типизированной переменной, передается в качестве аргумента или используется в контексте, где известен точный тип (целевой тип), то все его ветки должны соответствовать этому типу. Вот, что мы делали до сих пор:
```java
String result = switch (ternaryBool) {
    case TRUE, FALSE -> "sane";
    default -> "insane";
};
```
Как итог — _switch_ присваивается переменной _String_ _result_. Следовательно, [String](String) является целевым типом, и все ветки должны возвращать результат этого типа.  

То же самое происходит и здесь:
```java
Serializable serializableMessage = switch (bool) {
    case TRUE, FALSE -> "sane";
    // note that we don't throw the exception!
    // but it's `Serializable`, so it matches the target type
    default -> new IllegalArgumentException("insane");
};
```
А что произойдет сейчас?
```java
// compiler infers super type of `String` and
// `IllegalArgumentException` ~> `Serializable`
var serializableMessage = switch (bool) {
    case TRUE, FALSE -> "sane";
    // note that we don't throw the exception!
    default -> new IllegalArgumentException("insane");
};
```
Про применение типа _var_ можно прочитать в статье: "[26 рекомендаций по использованию типа var в Java](https://topjava.ru/blog/26-items-for-dissecting-java-local-variable-type-inference)".  

Если целевой тип неизвестен из-за использования [var](var), то он вычисляется путем нахождения наиболее конкретного супертипа из типов, создаваемых ветками.

##### Ранний возврат

Для выхода из оператора _switch_ (**да, для старой версии _switch_ тоже можно использовать оператор стрелку, но от этого он не становится выражением**) и метода можно использовать _return:_
```java
public String sanity(Bool ternaryBool) {
    switch (ternaryBool) {
        // `return` is only possible from block
        case TRUE, FALSE -> { return "sane"; }
        default -> { return "This is ridiculous!"; }
    }
}
```
Оператор стрелку можно использовать для обычного _switch_ не только для выхода из метода, что позволяет не использовать _break_ и не проваливаться в последующие _case_:
```java
int result = 0;
switch (sign) {
    case '+' -> result = a + b;
    case '^' -> {
        result = 1;    
        for (int i = 1; i <= b; i++) {
            result *= a;
        }
    }
    default -> System.out.println("Мат. операция не поддерживается");
}
```
А вот внутри выражения использовать _return_ уже не получится:
```java
public String sanity(Bool ternaryBool) {
    String result = switch (ternaryBool) {
        // this does not compile - error:
        // "return outside of enclosing switch expression"
        case TRUE, FALSE -> { return "sane"; }
        default -> { return "This is ridiculous!"; }
    };
}
```
Это имеет смысл независимо от того, используете ли вы стрелку или двоеточие.

##### Охват всех значений (исчерпываемость)

**Если вы используете _switch_ в качестве оператора, тогда не имеет значения, охвачены все варианты или нет.** Конечно, вы можете случайно пропустить _case_, и код будет работать неправильно, но компилятору все равно — вы, ваша _IDE_ и ваши инструменты анализа кода останетесь с этим наедине.  

Switch-выражения усугубляют эту проблему. Куда следует перейти _switch_, если нужная метка отсутствует? Единственный ответ, который может дать Java — это возвращать _null_ для ссылочных типов и значение по умолчанию для примитивов. Это породило бы множество ошибок в основном коде.  

Чтобы предотвратить такой исход, компилятор может помочь вам. **Для switch-выражений компилятор будет настаивать, чтобы все возможные варианты были охвачены.** Для каждого возможного значения в _switch_ должна быть ветвь — это называется исчерпываемостью.

Давайте посмотрим на пример, который может привести к ошибке компиляции:
```java
// compile error:
// "the switch expression does not cover all possible input values"
boolean result = switch (ternaryBool) {
    case TRUE -> true;
    // no case for `FALSE`
    case FILE_NOT_FOUND -> throw new UncheckedIOException(
            "This is ridiculous!",
            new FileNotFoundException());
};
```
Интересным является следующее решение: добавление ветки _default_, конечно, исправит ошибку, но это не является единственным решением — еще можно добавить _case_ для _FALSE_.
```java
// compiles without `default` branch because
// all cases for `ternaryBool` are covered
boolean result = switch (ternaryBool) {
    case TRUE -> true;
    case FALSE -> false;
    case FILE_NOT_FOUND -> throw new UncheckedIOException(
            "This is ridiculous!",
            new FileNotFoundException());
};
```

Да, компилятор наконец-то сможет определить, охватываются ли все значения _enum_, что позволяет не использовать бесполезные значения в _default!_  

Что касается исчерпываемости, я стараюсь избегать ветвей по умолчанию, когда это возможно, предпочитая получать ошибки компиляции, когда что-то меняется.

Хотя, это все же вызывает один вопрос. Что делать, если кто-то возьмет и превратит сумасшедший _Bool_ в кватернионный (с четырьмя значениями) _boolean_, добавив четвертое значение? Если вы перекомпилируете switch-выражение для расширенного _Bool_, то получите ошибку компиляции (т. к. выражение больше не будет исчерпывающим). Чтобы отловить эту проблему, компилятор переходит в ветку _default_, которая ведет себя так же, как та, которую мы использовали до сих пор, вызывая исключение.  

В настоящее время охват всех значений без ветки _default_ работает только для _enum_, но когда _switch_ в будущих версиях Java станет более мощным, он также сможет работать и с произвольными типами. Если метки _case_ смогут не только проверять равенство, но и проводить сравнения (например _ < 5 -> …) — это позволит охватить все варианты для числовых типов.

#### Как пользоваться switch в современной Java

До этого мы рассматривали изменения, которые произошли до Java 14. Теперь обсудим то, что было реализовано после.

##### Паттерны (шаблоны)

Реализация _[сопоставления с образцом](https://nipafx.dev/java-pattern-matching/)_ в _switch_ все еще находится в процессе разработки, но есть три аспекта, которые особенно интересны по данной теме.

##### Паттерны типов

На момент написания статьи Java поддерживает только [паттерны типов](https://nipafx.dev/java-type-pattern-matching/) (Type Patterns) с паттернами деконструкции для записей (records), предложенными [JEP 405](https://openjdk.java.net/jeps/405). Их уже можно использовать в операторах _if и_ _switch_:
```java
Object obj = // ...

// работает с Java 16
if (obj instanceof String str)
    callStringMethod(str);
else if (obj instanceof Number no)
    callNumberMethod(no);
else
    callObjectMethod(obj);

// работает (как превью) с JDK 17+
switch (obj) {
    case String str -> callStringMethod(str);
    case Number no -> callNumberMethod(no);
    default -> callObjectMethod(obj);
}
```
Я думаю, что с такими возможностями _switch_ станет более функциональным и интуитивным за счет того, что:  
- более четко выражает намерение выполнить ровно одну ветвь на основе свойств _obj_
- компилятор проверяет исчерпываемость
- если необходимо вычислить значение, то использование _switch_ в качестве выражения является более кратким

#### Применение уточнений (Clauses)

Уточнения ([ранее](https://openjdk.java.net/jeps/420) — guarded patterns) расширяют возможности паттерна с помощью дополнительных логических проверок. Это может быть представлено следующим образом:
```java
String str = // ...
String length = switch (str) {
    case str.length() > 42 -> "long";
    case str.length() > 19 -> "medium";
    case str.length() > 1 -> "small";
    case null || str.length() == 0 -> "empty";
};
```
По мере того как _switch_ становится все более мощным, я предполагаю, что он начнет поглощать части кода, для реализации которых используется _if-else-if_.

#### Заключение

Из статьи мы узнали, что Java превращает _switch_ в выражение, наделяя его новыми возможностями:  
- теперь один _case_ может соответствовать нескольким меткам
- новая стрелочная форма _case … -> …_ следует синтаксису [лямбда-выражений](Lambda):  
    - допускаются однострочные операторы или блоки
    - предотвращается сквозной переход к следующему _case_
- теперь все выражение оценивается, как значение, которое затем может быть присвоено переменной или передано, как часть более крупного оператора
- множественное выражение: если целевой тип известен, то все ветки должны ему соответствовать. В противном случае определяется конкретный тип, который соответствует всем веткам
- _yield_ возвращает значение из блока
- для выражения _switch,_ использующее _enum_, компилятор проверяет охват всех его значений. Если _default_ отсутствует, добавляется ветка, которая вызывает исключение
- если шаблоны станут более функциональными, то они смогут сделать _switch_ предпочтительнее _if_

